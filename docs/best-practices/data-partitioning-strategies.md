---
title: Strategien für die Datenpartitionierung
titleSuffix: Best practices for cloud applications
description: Leitfaden zum Trennen von Datenpartitionen für separate Verwaltung und separaten Zugriff
author: dragon119
ms.date: 11/04/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: cfbe877a4e3a4a1d5aa87c4a77ad2c5f23a6d664
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/23/2019
ms.locfileid: "54484481"
---
# <a name="data-partitioning-strategies"></a><span data-ttu-id="cb256-103">Strategien für die Datenpartitionierung</span><span class="sxs-lookup"><span data-stu-id="cb256-103">Data partitioning strategies</span></span>

<span data-ttu-id="cb256-104">In diesem Artikel werden einige Strategien für die Partitionierung von Daten in verschiedenen Azure-Datenspeichern beschrieben.</span><span class="sxs-lookup"><span data-stu-id="cb256-104">This article describes some strategies for partitioning data in various Azure data stores.</span></span> <span data-ttu-id="cb256-105">Allgemeine Informationen zur Verwendung der Datenpartitionierung sowie Best Practices finden Sie unter [Datenpartitionierung](./data-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="cb256-105">For general guidance about when to partition data and best practices, see [Data partitioning](./data-partitioning.md)</span></span>

## <a name="partitioning-azure-sql-database"></a><span data-ttu-id="cb256-106">Partitionieren von Azure SQL-Datenbank</span><span class="sxs-lookup"><span data-stu-id="cb256-106">Partitioning Azure SQL Database</span></span>

<span data-ttu-id="cb256-107">Eine einzelne SQL-Datenbank kann jeweils nur eine bestimmte Datenmenge enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-107">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="cb256-108">Der Durchsatz wird durch architekturbezogene Faktoren sowie die Anzahl von gleichzeitigen Verbindungen eingeschränkt, die von der Datenbank unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-108">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span>

<span data-ttu-id="cb256-109">[Pools für elastische Datenbanken](/azure/sql-database/sql-database-elastic-pool) unterstützen die horizontale Skalierung für eine SQL­-Datenbank.</span><span class="sxs-lookup"><span data-stu-id="cb256-109">[Elastic pools](/azure/sql-database/sql-database-elastic-pool) support horizontal scaling for a SQL database.</span></span> <span data-ttu-id="cb256-110">Mithilfe von Pools für elastische Datenbanken können Sie Ihre Daten in Shards partitionieren, die über mehrere SQL-Datenbanken verteilt sind.</span><span class="sxs-lookup"><span data-stu-id="cb256-110">Using elastic pools, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="cb256-111">Sie können Shards auch hinzufügen oder entfernen, wenn die zu verarbeitende Datenmenge wächst oder schrumpft.</span><span class="sxs-lookup"><span data-stu-id="cb256-111">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="cb256-112">Pools für elastische Datenbanken können auch zur Verringerung von Konflikten beitragen, indem die Last auf mehrere Datenbanken verteilt wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-112">Elastic pools can also help reduce contention by distributing the load across databases.</span></span>

<span data-ttu-id="cb256-113">Jedes Shard wird als SQL-Datenbank implementiert.</span><span class="sxs-lookup"><span data-stu-id="cb256-113">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="cb256-114">Ein Shard kann mehrere Datasets (sogenannte *Shardlets*) enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-114">A shard can hold more than one dataset (called a *shardlet*).</span></span> <span data-ttu-id="cb256-115">Jede Datenbank verwaltet Metadaten, die die darin enthaltenen Shardlets beschreiben.</span><span class="sxs-lookup"><span data-stu-id="cb256-115">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="cb256-116">Ein Shardlet kann ein einzelnes Datenelement oder eine Gruppe von Elementen sein, die den gleichen Shardlet-Schlüssel verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb256-116">A shardlet can be a single data item, or a group of items that share the same shardlet key.</span></span> <span data-ttu-id="cb256-117">In einer mehrinstanzenfähigen Anwendung kann der Shardlet-Schlüssel beispielsweise die Mandanten-ID sein, und alle Daten für einen Mandanten können im gleichen Shardlet gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-117">For example, in a multitenant application, the shardlet key can be the tenant ID, and all data for a tenant can be held in the same shardlet.</span></span>

<span data-ttu-id="cb256-118">Die Zuordnung von Dataset und Shardlet-Schlüssel erfolgt in Clientanwendungen.</span><span class="sxs-lookup"><span data-stu-id="cb256-118">Client applications are responsible for associating a dataset with a shardlet key.</span></span> <span data-ttu-id="cb256-119">Eine separate SQL-Datenbank fungiert als globaler Shardzuordnungs-Manager.</span><span class="sxs-lookup"><span data-stu-id="cb256-119">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="cb256-120">Diese Datenbank verfügt über eine Liste aller Shards und Shardlets im System.</span><span class="sxs-lookup"><span data-stu-id="cb256-120">This database has a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="cb256-121">Die Anwendung stellt eine Verbindung mit der Shardzuordnungs-Manager-Datenbank her, um eine Kopie der Shardzuordnung zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-121">The application connects to the shard map manager database to obtain a copy of the shard map.</span></span> <span data-ttu-id="cb256-122">Die Shardzuordnung wird lokal zwischengespeichert und von der Anwendung verwendet, um Datenanforderungen an den entsprechenden Shard weiterzuleiten.</span><span class="sxs-lookup"><span data-stu-id="cb256-122">It caches the shard map locally, and uses the map to route data requests to the appropriate shard.</span></span> <span data-ttu-id="cb256-123">Diese Funktion ist hinter einer Reihe von APIs aus der [Clientbibliothek für elastische Datenbanken](/azure/sql-database/sql-database-elastic-database-client-library) verborgen, die für Java und .NET zur Verfügung steht.</span><span class="sxs-lookup"><span data-stu-id="cb256-123">This functionality is hidden behind a series of APIs that are contained in the [Elastic Database client library](/azure/sql-database/sql-database-elastic-database-client-library), which is available for Java and .NET.</span></span>

<span data-ttu-id="cb256-124">Weitere Informationen zu Pools für elastische Datenbanken finden Sie unter [Horizontales Hochskalieren mit Azure SQL-Datenbank](/azure/sql-database/sql-database-elastic-scale-introduction).</span><span class="sxs-lookup"><span data-stu-id="cb256-124">For more information about elastic pools, see [Scaling out with Azure SQL Database](/azure/sql-database/sql-database-elastic-scale-introduction).</span></span>

<span data-ttu-id="cb256-125">Sie können die globale Shardzuordnungs-Manager-Datenbank replizieren, um die Wartezeit zu verringern und die Verfügbarkeit zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="cb256-125">To reduce latency and improve availability, you can replicate the global shard map manager database.</span></span> <span data-ttu-id="cb256-126">Mit den Premium-Tarifen können Sie die aktive Georeplikation konfigurieren, um kontinuierlich Daten in Datenbanken in verschiedenen Regionen zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-126">With the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span>

<span data-ttu-id="cb256-127">Alternativ können Sie die [Azure SQL-Datensynchronisierung](/azure/sql-database/sql-database-sync-data) oder [Azure Data Factory](/azure/data-factory/) verwenden, um die Shardzuordnungs-Manager-Datenbank regionsübergreifend zu replizieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-127">Alternatively, use [Azure SQL Data Sync](/azure/sql-database/sql-database-sync-data) or [Azure Data Factory](/azure/data-factory/) to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="cb256-128">Diese Form der Replikation wird in regelmäßigen Abständen ausgeführt und eignet sich besser, wenn die Shardzuordnung unregelmäßig geändert wird. Außerdem benötigt sie keinen Premium-Tarif.</span><span class="sxs-lookup"><span data-stu-id="cb256-128">This form of replication runs periodically and is more suitable if the shard map changes infrequently, and does not require Premium tier.</span></span>

<span data-ttu-id="cb256-129">Elastische Datenbanken bieten zwei Schemas für das Zuordnen von Daten zu Shardlets und deren Speicherung in Shards:</span><span class="sxs-lookup"><span data-stu-id="cb256-129">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

- <span data-ttu-id="cb256-130">Eine **listenbasierte Shardzuordnung** ordnet einen einzelnen Schlüssel einem Shardlet zu.</span><span class="sxs-lookup"><span data-stu-id="cb256-130">A **list shard map** associates a single key to a shardlet.</span></span> <span data-ttu-id="cb256-131">In einem mehrinstanzenfähigen System können beispielsweise die Daten für jeden Mandanten einem eindeutigen Schlüssel zugeordnet und in einem eigenen Shardlet gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-131">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="cb256-132">Zur Gewährleistung der Isolation kann jedes Shardlet innerhalb seines eigenen Shards gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-132">To guarantee isolation, each shardlet can be held within its own shard.</span></span>

    ![Verwenden einer listenbasierten Shardzuordnung zum Speichern von Mandantendaten in separaten Shards](./images/data-partitioning/PointShardlet.png)

- <span data-ttu-id="cb256-134">Eine **bereichsbasierte Shardzuordnung** ordnet eine Reihe zusammenhängender Schlüsselwerte einem Shardlet zu.</span><span class="sxs-lookup"><span data-stu-id="cb256-134">A **range shard map** associates a set of contiguous key values to a shardlet.</span></span> <span data-ttu-id="cb256-135">So können Sie beispielsweise die Daten für eine Reihe von Mandanten (die jeweils einen eigenen Schlüssel besitzen) innerhalb des gleichen Shardlets gruppieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-135">For example, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="cb256-136">Dieses Schema ist kostengünstiger als das erste, da Mandanten Datenspeicher gemeinsam nutzen, dies geht jedoch zulasten der Isolation.</span><span class="sxs-lookup"><span data-stu-id="cb256-136">This scheme is less expensive than the first, because tenants share data storage, but has less isolation.</span></span>

    ![Verwenden einer bereichsbasierten Shardzuordnung zum Speichern von Daten für einen Reihe von Mandanten in einem Shard](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="cb256-138">Ein einzelner Shard kann die Daten für mehrere Shardlets enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-138">A single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="cb256-139">Beispielsweise können Sie listenbasierte Shardlets verwenden, um Daten für verschiedene nicht zusammenhängende Mandanten im gleichen Shard zu speichern.</span><span class="sxs-lookup"><span data-stu-id="cb256-139">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="cb256-140">Sie können auch bereichs- und listenbasierte Shardlets im gleichen Shard kombinieren. Für die Adressierung werden allerdings unterschiedliche Zuordnungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="cb256-140">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps.</span></span> <span data-ttu-id="cb256-141">Dieser Ansatz wird im folgenden Diagramm veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="cb256-141">The following diagram shows this approach:</span></span>

![Implementieren von mehreren Shardzuordnungen](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="cb256-143">Pools für elastische Datenbanken ermöglichen das Hinzufügen und Entfernen von Shards, wenn sich das Datenvolumen verringert oder erhöht.</span><span class="sxs-lookup"><span data-stu-id="cb256-143">Elastic pools makes it possible to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="cb256-144">Clientanwendungen können Shards dynamisch erstellen und löschen und den Shardzuordnungs-Manager transparent aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-144">Client applications can create and delete shards dynamically, and transparently update the shard map manager.</span></span> <span data-ttu-id="cb256-145">Das Entfernen eines Shards ist jedoch ein destruktiver Vorgang, der auch das Löschen aller Daten in diesem Shard erfordert.</span><span class="sxs-lookup"><span data-stu-id="cb256-145">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="cb256-146">Wenn eine Anwendung einen Shard in zwei separate Shards aufteilen oder Shards miteinander kombinieren muss, verwenden Sie das [Split-Merge-Tool](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span><span class="sxs-lookup"><span data-stu-id="cb256-146">If an application needs to split a shard into two separate shards or combine shards, use the [split-merge tool](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span></span> <span data-ttu-id="cb256-147">Dieses Tool wird als Azure-Webdienst ausgeführt und migriert Daten sicher zwischen Shards.</span><span class="sxs-lookup"><span data-stu-id="cb256-147">This tool runs as an Azure web service, and migrates data safely between shards.</span></span>

<span data-ttu-id="cb256-148">Das Partitionierungsschema kann sich erheblich auf die Leistung des Systems auswirken.</span><span class="sxs-lookup"><span data-stu-id="cb256-148">The partitioning scheme can significantly impact the performance of your system.</span></span> <span data-ttu-id="cb256-149">Es kann sich auch darauf auswirken, wie häufig Shards hinzugefügt oder entfernt oder Daten über Shards hinweg neu partitioniert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="cb256-149">It can also affect the rate at which shards have to be added or removed, or that data must be repartitioned across shards.</span></span> <span data-ttu-id="cb256-150">Beachten Sie die folgenden Punkte:</span><span class="sxs-lookup"><span data-stu-id="cb256-150">Consider the following points:</span></span>

- <span data-ttu-id="cb256-151">Gruppieren Sie Daten, die im gleichen Shard verwendet werden, und vermeiden Sie Vorgänge, die auf Daten aus mehreren Shards zugreifen.</span><span class="sxs-lookup"><span data-stu-id="cb256-151">Group data that is used together in the same shard, and avoid operations that access data from multiple shards.</span></span> <span data-ttu-id="cb256-152">Ein Shard ist eine eigenständige SQL-Datenbank, und datenbankübergreifende Verknüpfungen müssen auf der Clientseite erfolgen.</span><span class="sxs-lookup"><span data-stu-id="cb256-152">A shard is a SQL database in its own right, and cross-database joins must be performed on the client side.</span></span>

    <span data-ttu-id="cb256-153">SQL-Datenbank unterstützt zwar keine datenbankübergreifenden Verknüpfungen, Sie können jedoch die Tools für elastische Datenbanken verwenden, um [Multishardabfragen](/azure/sql-database/sql-database-elastic-scale-multishard-querying) auszuführen.</span><span class="sxs-lookup"><span data-stu-id="cb256-153">Although SQL Database does not support cross-database joins, you can use the Elastic Database tools to perform [mutli-shard queries](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span></span> <span data-ttu-id="cb256-154">Bei einer Multishardabfrage werden einzelne Abfragen an die individuellen Datenbanken gesendet und die Ergebnisse zusammengeführt.</span><span class="sxs-lookup"><span data-stu-id="cb256-154">A multi-shard query sends individual queries to each database and merges the results.</span></span>

- <span data-ttu-id="cb256-155">Entwerfen Sie kein System, in dem Abhängigkeiten zwischen Shards bestehen.</span><span class="sxs-lookup"><span data-stu-id="cb256-155">Don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="cb256-156">Einschränkungen für die referenzielle Integrität, Trigger und gespeicherte Prozeduren in einer einzelnen Datenbank dürfen nicht auf Objekte in einer anderen Datenbank verweisen.</span><span class="sxs-lookup"><span data-stu-id="cb256-156">Referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span>

- <span data-ttu-id="cb256-157">Wenn Sie über Verweisdaten verfügen, die von Abfragen häufig verwendet werden, empfiehlt es sich unter Umständen, diese Daten shardübergreifend zu replizieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-157">If you have reference data that is frequently used by queries, consider replicating this data across shards.</span></span> <span data-ttu-id="cb256-158">Dadurch müssen Daten ggf. nicht datenbankübergreifend verknüpft werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-158">This approach can remove the need to join data across databases.</span></span> <span data-ttu-id="cb256-159">Im Idealfall sollten diese Daten statisch sein oder sich nur langsam verändern, um den Replikationsaufwand zu minimieren und eine Veraltung der Daten zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="cb256-159">Ideally, such data should be static or slow-moving, to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

- <span data-ttu-id="cb256-160">Shardlets, die zur gleichen Shardzuordnung gehören, sollten das gleiche Schema besitzen.</span><span class="sxs-lookup"><span data-stu-id="cb256-160">Shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="cb256-161">Diese Regel wird von SQL-Datenbank zwar nicht erzwungen, die Datenverwaltung und Abfragen werden jedoch sehr komplex, wenn jedes Shardlet ein anderes Schema hat.</span><span class="sxs-lookup"><span data-stu-id="cb256-161">This rule is not enforced by SQL Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="cb256-162">Erstellen Sie stattdessen separate Shardzuordnungen für jedes Schema.</span><span class="sxs-lookup"><span data-stu-id="cb256-162">Instead, create separate shard maps for each schema.</span></span> <span data-ttu-id="cb256-163">Denken Sie daran, dass Daten, die zu unterschiedlichen Shardlets gehören, im gleichen Shard gespeichert werden können.</span><span class="sxs-lookup"><span data-stu-id="cb256-163">Remember that data belonging to different shardlets can be stored in the same shard.</span></span>

- <span data-ttu-id="cb256-164">Transaktionsvorgänge werden nur für Daten innerhalb eines Shards unterstützt, nicht über Shards hinweg.</span><span class="sxs-lookup"><span data-stu-id="cb256-164">Transactional operations are only supported for data within a shard, and not across shards.</span></span> <span data-ttu-id="cb256-165">Transaktionen können sich über Shardlets erstrecken, solange sie dem gleichen Shard angehören.</span><span class="sxs-lookup"><span data-stu-id="cb256-165">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="cb256-166">Wenn Ihre Geschäftslogik Transaktionen ausführen muss, sollten Sie die Daten daher in der gleichen Shard speichern oder letztendliche Konsistenz implementieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-166">Therefore, if your business logic needs to perform transactions, either store the data in the same shard or implement eventual consistency.</span></span>

- <span data-ttu-id="cb256-167">Platzieren Sie Shards in der Nähe der Benutzer, die auf die Daten in diesen Shards zugreifen.</span><span class="sxs-lookup"><span data-stu-id="cb256-167">Place shards close to the users that access the data in those shards.</span></span> <span data-ttu-id="cb256-168">Diese Strategie hilft dabei, Latenzen zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-168">This strategy helps reduce latency.</span></span>

- <span data-ttu-id="cb256-169">Vermeiden Sie eine Mischung aus sehr aktiven und relativ inaktiven Shards.</span><span class="sxs-lookup"><span data-stu-id="cb256-169">Avoid having a mixture of highly active and relatively inactive shards.</span></span> <span data-ttu-id="cb256-170">Versuchen Sie, die Last gleichmäßig über Shards hinweg zu verteilen.</span><span class="sxs-lookup"><span data-stu-id="cb256-170">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="cb256-171">Dies erfordert möglicherweise ein Hashing der Shardschlüssel.</span><span class="sxs-lookup"><span data-stu-id="cb256-171">This might require hashing the sharding keys.</span></span> <span data-ttu-id="cb256-172">Stellen Sie bei der Geolokalisierung von Shards sicher, dass die Schlüssel mit Hash Shardlets zugeordnet sind, die in der Nähe der Benutzer gespeichert sind, die auf diese Daten zugreifen.</span><span class="sxs-lookup"><span data-stu-id="cb256-172">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>

### <a name="partitioning-azure-table-storage"></a><span data-ttu-id="cb256-173">Partitionierung des Microsoft Azure-Tabellenspeichers</span><span class="sxs-lookup"><span data-stu-id="cb256-173">Partitioning Azure table storage</span></span>

<span data-ttu-id="cb256-174">Azure-Tabellenspeicher ist ein Schlüssel-Wert-Speicher, der mit Fokus auf die Partitionierung entworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="cb256-174">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="cb256-175">Alle Entitäten werden in einer Partition gespeichert und Partitionen werden intern von Azure-Tabellenspeicher verwaltet.</span><span class="sxs-lookup"><span data-stu-id="cb256-175">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="cb256-176">Jede in einer Tabelle gespeicherte Entität muss einen zweiteiligen Schlüssel bereitstellen, der Folgendes umfasst:</span><span class="sxs-lookup"><span data-stu-id="cb256-176">Each entity stored in a table must provide a two-part key that includes:</span></span>

- <span data-ttu-id="cb256-177">**Partitionsschlüssel**:</span><span class="sxs-lookup"><span data-stu-id="cb256-177">**The partition key**.</span></span> <span data-ttu-id="cb256-178">Dieser Zeichenfolgenwert bestimmt, in welcher Partition der Azure-Tabellenspeicher die Entität platzieren soll.</span><span class="sxs-lookup"><span data-stu-id="cb256-178">This is a string value that determines the partition where Azure table storage will place the entity.</span></span> <span data-ttu-id="cb256-179">Alle Entitäten mit dem gleichen Partitionsschlüssel werden in der gleichen Partition gespeichert.</span><span class="sxs-lookup"><span data-stu-id="cb256-179">All entities with the same partition key are stored in the same partition.</span></span>

- <span data-ttu-id="cb256-180">**Zeilenschlüssel**:</span><span class="sxs-lookup"><span data-stu-id="cb256-180">**The row key**.</span></span> <span data-ttu-id="cb256-181">Dieser Zeichenfolgewert gibt die Entität innerhalb der Partition an.</span><span class="sxs-lookup"><span data-stu-id="cb256-181">This is a string value that identifies the entity within the partition.</span></span> <span data-ttu-id="cb256-182">Alle Entitäten innerhalb einer Partition werden durch diesen Schlüssel lexikalisch, in aufsteigender Reihenfolge sortiert.</span><span class="sxs-lookup"><span data-stu-id="cb256-182">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="cb256-183">Die Kombination aus Partitions- und Zeilenschlüssel muss für jede Entität eindeutig sein und darf 1 KB Länge nicht überschreiten.</span><span class="sxs-lookup"><span data-stu-id="cb256-183">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="cb256-184">Wenn eine Entität einer Tabelle mit einem zuvor nicht verwendetem Partitionsschlüssel hinzugefügt wird, erstellt der Azure-Tabellenspeicher eine neue Partition für diese Entität.</span><span class="sxs-lookup"><span data-stu-id="cb256-184">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="cb256-185">Andere Entitäten mit demselben Partitionsschlüssel werden in der gleichen Partition gespeichert.</span><span class="sxs-lookup"><span data-stu-id="cb256-185">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="cb256-186">Dieser Mechanismus implementiert effektiv eine Strategie für die automatische Skalierungsstrategie.</span><span class="sxs-lookup"><span data-stu-id="cb256-186">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="cb256-187">Jede Partition wird auf dem gleichen Server in einem Azure-Datencenter gespeichert, um sicherzustellen, dass Abfragen, die Daten aus einer einzelnen Partition abrufen, schnell ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-187">Each partition is stored on the same server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span>

<span data-ttu-id="cb256-188">Microsoft hat [Skalierbarkeitsziele] für Azure Storage veröffentlicht.</span><span class="sxs-lookup"><span data-stu-id="cb256-188">Microsoft has published [scalability targets] for Azure Storage.</span></span> <span data-ttu-id="cb256-189">Wenn Ihr System diese Grenzwerte voraussichtlich überschreitet, empfiehlt es sich ggf., Entitäten auf mehrere Tabellen aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="cb256-189">If your system is likely to exceed these limits, consider splitting entities into multiple tables.</span></span> <span data-ttu-id="cb256-190">Verwenden Sie die vertikale Partitionierung, um die Felder in die Gruppen zu teilen, auf die höchstwahrscheinlich gemeinsam zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-190">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="cb256-191">Das folgende Diagramm zeigt die logische Struktur eines Beispielspeicherkontos.</span><span class="sxs-lookup"><span data-stu-id="cb256-191">The following diagram shows the logical structure of an example storage account.</span></span> <span data-ttu-id="cb256-192">Das Speicherkonto enthält drei Tabellen: eine mit Kundeninformationen, eine mit Produktinformationen und eine mit Bestellinformationen.</span><span class="sxs-lookup"><span data-stu-id="cb256-192">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span>

![Die Tabellen und Partitionen in einem Beispielspeicherkonto](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="cb256-194">Jede Tabelle verfügt über mehrere Partitionen.</span><span class="sxs-lookup"><span data-stu-id="cb256-194">Each table has multiple partitions.</span></span>

- <span data-ttu-id="cb256-195">In der Tabelle mit den Kundeninformationen sind die Daten nach der Stadt partitioniert, in der sich der Kunde befindet.</span><span class="sxs-lookup"><span data-stu-id="cb256-195">In the Customer Info table, the data is partitioned according to the city where the customer is located.</span></span> <span data-ttu-id="cb256-196">Der Zeilenschlüssel enthält die Kunden-ID.</span><span class="sxs-lookup"><span data-stu-id="cb256-196">The row key contains the customer ID.</span></span>
- <span data-ttu-id="cb256-197">In der Tabelle mit den Produktinformationen sind die Produkte nach Kategorie partitioniert, und der Zeilenschlüssel enthält die Produktnummer.</span><span class="sxs-lookup"><span data-stu-id="cb256-197">In the Product Info table, products are partitioned by product category, and the row key contains the product number.</span></span>
- <span data-ttu-id="cb256-198">In der Tabelle mit den Bestellinformationen sind die Bestellungen nach dem Bestelldatum partitioniert, und der Zeilenschlüssel gibt die Zeit an, zu der die Bestellung eingegangen ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-198">In the Order Info table, the orders are partitioned by order date, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="cb256-199">Beachten Sie, dass alle Daten anhand der Zeilenschlüssel in jeder Partition sortiert sind.</span><span class="sxs-lookup"><span data-stu-id="cb256-199">Note that all data is ordered by the row key in each partition.</span></span>

<span data-ttu-id="cb256-200">Berücksichtigen Sie die folgenden Punkte beim Entwerfen der Entitäten für den Azure-Tabellenspeicher:</span><span class="sxs-lookup"><span data-stu-id="cb256-200">Consider the following points when you design your entities for Azure table storage:</span></span>

- <span data-ttu-id="cb256-201">Berücksichtigen Sie bei der Wahl des Partitions- und Zeilenschlüssels, wie auf die Daten zugegriffen wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-201">Select a partition key and row key by how the data is accessed.</span></span> <span data-ttu-id="cb256-202">Wählen Sie eine Kombination aus Partitions- und Zeilenschlüssel, die den Großteil Ihrer Abfragen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="cb256-202">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="cb256-203">Die effizientesten Abfragen rufen Daten durch Angeben des Partitions- und des Zeilenschlüssels ab.</span><span class="sxs-lookup"><span data-stu-id="cb256-203">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="cb256-204">Abfragen, die einen Partitionsschlüssel und einen Zeilenschlüsselbereich angeben, können durch Durchsuchen einer einzigen Partition ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-204">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="cb256-205">Dies ist ein relativ schneller Vorgang, da die Daten in der Reihenfolge der Zeilenschlüssel gespeichert sind.</span><span class="sxs-lookup"><span data-stu-id="cb256-205">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="cb256-206">Bei Abfragen ohne Angabe der zu überprüfenden Partition muss jede Partition überprüft werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-206">If queries don't specify which partition to scan, every partition must be scanned.</span></span>

- <span data-ttu-id="cb256-207">Wenn eine Entität einen natürlichen Schlüssel hat, dann verwenden Sie diesen als Partitionsschlüssel und geben Sie eine leere Zeichenfolge als Zeilenschlüssel an.</span><span class="sxs-lookup"><span data-stu-id="cb256-207">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="cb256-208">Wenn eine Entität über einen zusammengesetzten Schlüssel aus zwei Eigenschaften verfügt, verwenden Sie die Eigenschaft, die sich am langsamsten ändert, als Partitionsschlüssel und die andere als Zeilenschlüssel.</span><span class="sxs-lookup"><span data-stu-id="cb256-208">If an entity has a composite key consisting of two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="cb256-209">Wenn eine Entität über mehr als zwei Schlüsseleigenschaften verfügt, verwenden Sie eine Verkettung der Eigenschaften, um die Partitions- und Zeilenschlüssel bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="cb256-209">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>

- <span data-ttu-id="cb256-210">Wenn Sie regelmäßig Abfragen ausführen, die Daten nicht anhand von Partitions- und Zeilenschlüssel, sondern unter Verwendung anderer Felder suchen, sollten Sie das [Indextabellenmuster](../patterns/index-table.md) implementieren oder einen anderen Datenspeicher mit Indizierungsunterstützung verwenden (beispielsweise Cosmos DB).</span><span class="sxs-lookup"><span data-stu-id="cb256-210">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [Index Table pattern](../patterns/index-table.md), or consider using a different data store that supports indexing, such as Cosmos DB.</span></span>

- <span data-ttu-id="cb256-211">Wenn Sie Partitionsschlüssel mit einer monotonen Sequenz generieren (etwa „0001“, „0002“, „0003“) und jede Partition nur eine begrenzte Datenmenge enthält, kann der Azure-Tabellenspeicher diese Partitionen physisch auf dem gleichen Server gruppieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-211">If you generate partition keys by using a monotonic sequence (such as "0001", "0002", "0003") and each partition only contains a limited amount of data, Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="cb256-212">Azure Storage geht davon aus, dass die Anwendung am ehesten Abfragen für einen zusammenhängenden Bereich von Partitionen (Bereichsabfragen) ausführt, und ist für diesen Fall optimiert.</span><span class="sxs-lookup"><span data-stu-id="cb256-212">Azure Storage assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="cb256-213">Dieser Ansatz kann jedoch zu Hotspots führen, da sich alle neu eingefügten Entitäten wahrscheinlich an einem Ende des zusammenhängenden Bereichs konzentrieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-213">However, this approach can lead to hotspots, because all insertions of new entities are likely to be concentrated at one end the contiguous range.</span></span> <span data-ttu-id="cb256-214">Er kann auch die Skalierbarkeit verringern.</span><span class="sxs-lookup"><span data-stu-id="cb256-214">It can also reduce scalability.</span></span> <span data-ttu-id="cb256-215">Eine gleichmäßigere Lastenverteilung lässt sich ggf. mittels Hashing des Partitionsschlüssels erreichen.</span><span class="sxs-lookup"><span data-stu-id="cb256-215">To spread the load more evenly, consider hashing the partition key.</span></span>

- <span data-ttu-id="cb256-216">Azure-Tabellenspeicher unterstützt Transaktionsvorgänge für Entitäten, die zur selben Partition gehören.</span><span class="sxs-lookup"><span data-stu-id="cb256-216">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="cb256-217">Eine Anwendung kann mehrere Einfüge-, Aktualisierungs-, Lösch-, Ersetzungs- oder Zusammenführungsvorgänge als atomische Einheit ausführen, sofern die Transaktion nicht mehr als 100 Entitäten umfasst und die Nutzlast der Anforderung 4 MB nicht übersteigt.</span><span class="sxs-lookup"><span data-stu-id="cb256-217">An application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit, as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB.</span></span> <span data-ttu-id="cb256-218">Vorgänge, die sich über mehrere Partitionen erstrecken, sind nicht transaktional und erfordern möglicherweise die Implementierung von letztlicher Konsistenz.</span><span class="sxs-lookup"><span data-stu-id="cb256-218">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency.</span></span> <span data-ttu-id="cb256-219">Weitere Informationen zu Tabellenspeicher und Transaktionen finden Sie unter [Ausführen von Entitätsgruppentransaktionen] (Ausführen von Entitätsgruppentransaktionen).</span><span class="sxs-lookup"><span data-stu-id="cb256-219">For more information about table storage and transactions, see [Performing entity group transactions].</span></span>

- <span data-ttu-id="cb256-220">Berücksichtigen Sie die Granularität des Partitionsschlüssels:</span><span class="sxs-lookup"><span data-stu-id="cb256-220">Consider the granularity of the partition key:</span></span>

  - <span data-ttu-id="cb256-221">Die Verwendung des gleichen Partitionsschlüssels für jede Entität führt zu einer einzelnen Partition auf einem einzelnen Server.</span><span class="sxs-lookup"><span data-stu-id="cb256-221">Using the same partition key for every entity results in a single partition that's held on one server.</span></span> <span data-ttu-id="cb256-222">Dies verhindert das horizontale Hochskalieren der Partition und konzentriert die Last auf einen einzelnen Server.</span><span class="sxs-lookup"><span data-stu-id="cb256-222">This prevents the partition from scaling out and focuses the load on a single server.</span></span> <span data-ttu-id="cb256-223">Folglich eignet sich dieser Ansatz nur zur Speicherung einer geringen Anzahl von Entitäten.</span><span class="sxs-lookup"><span data-stu-id="cb256-223">As a result, this approach is only suitable for storing a small number of entities.</span></span> <span data-ttu-id="cb256-224">Andererseits können bei diesem Ansatz alle Entitäten in Entitätsgruppentransaktionen einbezogen werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-224">However, it does ensure that all entities can participate in entity group transactions.</span></span>

  - <span data-ttu-id="cb256-225">Die Verwendung eines eindeutigen Partitionsschlüssels für jede Entität führt dazu, dass der Tabellenspeicherdienst eine separate Partition für jede Entität erstellt, was möglicherweise zu einer großen Anzahl von kleinen Partitionen führt.</span><span class="sxs-lookup"><span data-stu-id="cb256-225">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions.</span></span> <span data-ttu-id="cb256-226">Dieser Ansatz bietet mehr Skalierbarkeit als ein einzelner Partitionsschlüssel, Gruppentransaktionen für Entitäten sind jedoch nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="cb256-226">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="cb256-227">Auch erfordern Abfragen, die mehr als eine Entität abrufen, möglicherweise Lesevorgänge auf mehr als einem Server.</span><span class="sxs-lookup"><span data-stu-id="cb256-227">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="cb256-228">Wenn die Anwendung jedoch Bereichsabfragen ausführt, kann die Verwendung einer monotonen Sequenz für die Partitionsschlüssel zur Optimierung dieser Abfragen beitragen.</span><span class="sxs-lookup"><span data-stu-id="cb256-228">However, if the application performs range queries, then using a monotonic sequence for the partition keys might help to optimize these queries.</span></span>

  - <span data-ttu-id="cb256-229">Die gemeinsame Verwendung eines einzelnen Partitionsschlüssels innerhalb einer Teilmenge von Entitäten ermöglicht es, verwandte Entitäten in der gleichen Partition zu gruppieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-229">Sharing the partition key across a subset of entities makes it possible to group related entities in the same partition.</span></span> <span data-ttu-id="cb256-230">Vorgänge mit verknüpften Entitäten lassen sich mithilfe von Gruppentransaktionen für Entitäten durchführen, und Abfragen, die einen Satz verknüpfter Entitäten abrufen, können durch Zugriff auf einen einzigen Server durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-230">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="cb256-231">Weitere Informationen finden Sie unter [Azure-Speichertabelle – Entwurfshandbuch].</span><span class="sxs-lookup"><span data-stu-id="cb256-231">For more information, see [Azure storage table design guide].</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="cb256-232">Partitionierung von Azure Blob Storage</span><span class="sxs-lookup"><span data-stu-id="cb256-232">Partitioning Azure blob storage</span></span>

<span data-ttu-id="cb256-233">Azure Blob Storage ermöglicht die Speicherung großer binärer Objekte.</span><span class="sxs-lookup"><span data-stu-id="cb256-233">Azure blob storage makes it possible to hold large binary objects.</span></span> <span data-ttu-id="cb256-234">Verwenden Sie Blockblobs in Szenarien, in denen Sie schnell große Datenmengen hoch- oder herunterladen müssen.</span><span class="sxs-lookup"><span data-stu-id="cb256-234">Use block blobs in scenarios when you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="cb256-235">Verwenden Sie Seitenblobs für Anwendungen, die eher zufälligen als seriellen Zugriff auf Teile der Daten erfordern.</span><span class="sxs-lookup"><span data-stu-id="cb256-235">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="cb256-236">Jedes Blob (Block oder Seite), wird in einem Container in einem Azure-Speicherkonten aufrechterhalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-236">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="cb256-237">Sie können Container verwenden, um verwandte Blobs zu gruppieren, für die die gleichen Sicherheitsanforderungen gelten.</span><span class="sxs-lookup"><span data-stu-id="cb256-237">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="cb256-238">Diese Gruppierung ist nicht physischer, sondern logischer Art.</span><span class="sxs-lookup"><span data-stu-id="cb256-238">This grouping is logical rather than physical.</span></span> <span data-ttu-id="cb256-239">In einem Container hat jedes Blob einen eindeutigen Namen.</span><span class="sxs-lookup"><span data-stu-id="cb256-239">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="cb256-240">Der Partitionsschlüssel für ein Blob setzt sich aus dem Kontonamen, Containernamen und Blobnamen zusammen.</span><span class="sxs-lookup"><span data-stu-id="cb256-240">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="cb256-241">Der Partitionsschlüssel wird zur Partitionierung von Daten in Bereiche verwendet, und diese Bereiche werden im Lastausgleich über das System verteilt.</span><span class="sxs-lookup"><span data-stu-id="cb256-241">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="cb256-242">Blobs können über mehrere Server verteilt werden, um den Zugriff darauf horizontal hochzuskalieren, aber ein einzelnes Blob kann nur von einem einzelnen Server bedient werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-242">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span>

<span data-ttu-id="cb256-243">Wenn Ihr Benennungsschema Zeitstempel oder numerische Bezeichner umfasst, kann dies zu übermäßigem Datenverkehr für eine Partition führen und einen effektiven Lastenausgleich verhindern.</span><span class="sxs-lookup"><span data-stu-id="cb256-243">If your naming scheme uses timestamps or numerical identifiers, it can lead to excessive traffic going to one partition, limiting the system from effectively load balancing.</span></span> <span data-ttu-id="cb256-244">Wenn Sie beispielsweise über täglich ausgeführte Vorgänge verfügen, die ein Blobobjekt mit einem Zeitstempel (etwa *JJJJ-MM-TT*) verwenden, wird der gesamte Datenverkehr für diesen Vorgang an einen einzelnen Partitionsserver gesendet.</span><span class="sxs-lookup"><span data-stu-id="cb256-244">For instance, if you have daily operations that use a blob object with a timestamp such as *yyyy-mm-dd*, all the traffic for that operation would go to a single partition server.</span></span> <span data-ttu-id="cb256-245">Es empfiehlt sich daher unter Umständen, den Namen mit einem dreistelligen Hashpräfix zu versehen.</span><span class="sxs-lookup"><span data-stu-id="cb256-245">Instead, consider prefixing the name with a 3-digit hash.</span></span> <span data-ttu-id="cb256-246">Weitere Informationen finden Sie unter [Partitionsbenennungskonvention](/azure/storage/common/storage-performance-checklist#subheading47).</span><span class="sxs-lookup"><span data-stu-id="cb256-246">For more information, see [Partition Naming Convention](/azure/storage/common/storage-performance-checklist#subheading47)</span></span>

<span data-ttu-id="cb256-247">Die Aktionen zum Schreiben eines einzelnen Blocks oder einer einzelnen Seite sind atomar. Vorgänge, die mehrere Blöcke, Seiten oder Blobs umfassen, dagegen nicht.</span><span class="sxs-lookup"><span data-stu-id="cb256-247">The actions of writing a single block or page are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="cb256-248">Wenn Sie bei der Ausführung von Schreibvorgängen Konsistenz zwischen Blöcken, Seiten und Blobs gewährleisten müssen, richten Sie mithilfe einer Bloblease eine Schreibsperre ein.</span><span class="sxs-lookup"><span data-stu-id="cb256-248">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="cb256-249">Partitionierung von Azure-Speicherwarteschlangen</span><span class="sxs-lookup"><span data-stu-id="cb256-249">Partitioning Azure storage queues</span></span>

<span data-ttu-id="cb256-250">Azure-Speicherwarteschlangen ermöglichen Ihnen asynchrones Messaging zwischen Prozessen.</span><span class="sxs-lookup"><span data-stu-id="cb256-250">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="cb256-251">Ein Azure-Speicherkonto kann eine beliebige Anzahl an Warteschlangen enthalten und jede Warteschlange kann eine beliebige Anzahl an Nachrichten enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-251">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="cb256-252">Die einzige Beschränkung ist der im Speicherkonto verfügbare Platz.</span><span class="sxs-lookup"><span data-stu-id="cb256-252">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="cb256-253">Die maximale Größe einer einzelnen Nachricht beträgt 64 KB.</span><span class="sxs-lookup"><span data-stu-id="cb256-253">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="cb256-254">Falls Sie größere Nachrichten erfordern, dann sollten Sie in Betracht ziehen, stattdessen Azure Service Bus-Warteschlangen zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb256-254">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="cb256-255">Jede Speicherwarteschlange verfügt über einen eindeutigen Namen innerhalb des Speicherkontos, in dem sie enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-255">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="cb256-256">Azure partitioniert Warteschlangen basierend auf dem Namen.</span><span class="sxs-lookup"><span data-stu-id="cb256-256">Azure partitions queues based on the name.</span></span> <span data-ttu-id="cb256-257">Alle Nachrichten für dieselbe Warteschlange werden in derselben Partition gespeichert, die von einem einzigen Server kontrolliert wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-257">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="cb256-258">Verschiedene Warteschlangen können von verschiedenen Servern verwaltet werden, um beim Lastausgleich zu helfen.</span><span class="sxs-lookup"><span data-stu-id="cb256-258">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="cb256-259">Die Zuordnung der Warteschlangen zu Servern ist für Anwendungen und Benutzer transparent.</span><span class="sxs-lookup"><span data-stu-id="cb256-259">The allocation of queues to servers is transparent to applications and users.</span></span>

<span data-ttu-id="cb256-260">Verwenden Sie in einer umfangreichen Anwendung nicht die gleiche Speicherwarteschlange für alle Instanzen der Anwendung, da bei diesen Ansatz der Server, der die Warteschlange hostet, zum Hotspot werden kann.</span><span class="sxs-lookup"><span data-stu-id="cb256-260">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="cb256-261">Verwenden Sie stattdessen verschiedene Warteschlangen für verschiedene Funktionsbereiche der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="cb256-261">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="cb256-262">Azure-Speicherwarteschlangen unterstützen keine Transaktionen, d.h. das Weiterleiten von Nachrichten an verschiedene Warteschlangen sollte nur eine geringe Auswirkung auf die Messaging-Konsistenz haben.</span><span class="sxs-lookup"><span data-stu-id="cb256-262">Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</span></span>

<span data-ttu-id="cb256-263">Eine Azure-Speicherwarteschlange kann bis zu 2.000 Nachrichten pro Sekunde verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="cb256-263">An Azure storage queue can handle up to 2,000 messages per second.</span></span> <span data-ttu-id="cb256-264">Wenn Sie Nachrichten schneller verarbeiten müssen, sollten Sie das Erstellen mehrerer Warteschlangen in Betracht ziehen.</span><span class="sxs-lookup"><span data-stu-id="cb256-264">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="cb256-265">Erstellen Sie z. B. in einer globalen Anwendung separate Speicherwarteschlangen in separaten Speicherkonten, um Anwendungsinstanzen zu verarbeiten, die in jeder Region ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-265">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-azure-service-bus"></a><span data-ttu-id="cb256-266">Partitionieren von Azure Service Bus</span><span class="sxs-lookup"><span data-stu-id="cb256-266">Partitioning Azure Service Bus</span></span>

<span data-ttu-id="cb256-267">Azure Service Bus verwendet einen Nachrichtenbroker, um Nachrichten zu verarbeiten, die an eine Service Bus-Warteschlange oder ein Topic gesendet wurden.</span><span class="sxs-lookup"><span data-stu-id="cb256-267">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="cb256-268">Standardmäßig werden alle an eine Warteschlange oder ein Topic gesendeten Nachrichten vom gleichen Nachrichtenbrokerprozess verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="cb256-268">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="cb256-269">Diese Architektur kann den Gesamtdurchsatz der Nachrichten-Warteschlange eingrenzen.</span><span class="sxs-lookup"><span data-stu-id="cb256-269">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="cb256-270">Sie können eine Warteschlange oder ein Topic jedoch auch während der Erstellung partitionieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-270">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="cb256-271">Legen Sie dazu die *EnablePartitioning*-Eigenschaft der Warteschlange oder des Themas *true* fest.</span><span class="sxs-lookup"><span data-stu-id="cb256-271">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="cb256-272">Eine partitionierte Warteschlange oder ein partitioniertes Topic ist in mehrere Fragmente unterteilt, von denen jedes durch einen separaten Nachrichtenspeicher und Nachrichtenbroker gesichert ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-272">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="cb256-273">Service Bus übernimmt die Verantwortung zum Erstellen und Verwalten dieser Fragmente.</span><span class="sxs-lookup"><span data-stu-id="cb256-273">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="cb256-274">Wenn eine Anwendung eine Nachricht an eine partitionierte Warteschlange oder ein partitioniertes Thema postet, ordnet Service Bus die Nachricht einem Fragment für diese Warteschlange oder dieses Thema zu.</span><span class="sxs-lookup"><span data-stu-id="cb256-274">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="cb256-275">Wenn eine Anwendung eine Nachricht von einer Warteschlange oder einem Abonnement empfängt, überprüft Service Bus jedes Fragment auf die nächste verfügbare Nachricht und leitet diese dann an die Anwendung zur Verarbeitung weiter.</span><span class="sxs-lookup"><span data-stu-id="cb256-275">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="cb256-276">Mit dieser Struktur kann die Last auf die Nachrichtenbroker und Nachrichtenspeicher verteilt werden, um die Skalierbarkeit und Verfügbarkeit zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="cb256-276">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="cb256-277">Wenn der Nachrichtenbroker oder der Nachrichtenspeicher für ein Fragment vorübergehend nicht verfügbar ist, kann Service Bus Nachrichten aus einem der anderen verfügbaren Fragmente abrufen.</span><span class="sxs-lookup"><span data-stu-id="cb256-277">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="cb256-278">Service Bus ordnet jeder Nachricht folgendermaßen ein Fragment zu:</span><span class="sxs-lookup"><span data-stu-id="cb256-278">Service Bus assigns a message to a fragment as follows:</span></span>

- <span data-ttu-id="cb256-279">Wenn die Nachricht zu einer Sitzung gehört, werden alle Nachrichten mit dem gleichen Wert für die Eigenschaft *SessionId* an das gleiche Fragment gesendet.</span><span class="sxs-lookup"><span data-stu-id="cb256-279">If the message belongs to a session, all messages with the same value for the *SessionId*  property are sent to the same fragment.</span></span>

- <span data-ttu-id="cb256-280">Wenn die Nachricht nicht zu einer Sitzung gehört, aber der Absender einen Wert für die *PartitionKey*-Eigenschaft angegeben hat, werden alle Nachrichten mit demselben *PartitionKey*-Wert an dasselbe Fragment gesendet.</span><span class="sxs-lookup"><span data-stu-id="cb256-280">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="cb256-281">Wenn die Eigenschaften *SessionId* und *PartitionKey* angegeben werden, müssen sie auf denselben Wert festgelegt werden. Andernfalls wird die Nachricht abgelehnt.</span><span class="sxs-lookup"><span data-stu-id="cb256-281">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>

- <span data-ttu-id="cb256-282">Wenn die Eigenschaften *SessionID* und *PartitionKey* für eine Nachricht nicht angegeben sind, aber Duplikaterkennung aktiviert ist, wird die *MessageID*-Eigenschaft verwendet.</span><span class="sxs-lookup"><span data-stu-id="cb256-282">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="cb256-283">Alle Nachrichten mit derselben *MessageID* werden an dasselbe Fragment geleitet.</span><span class="sxs-lookup"><span data-stu-id="cb256-283">All messages with the same *MessageId* will be directed to the same fragment.</span></span>

- <span data-ttu-id="cb256-284">Wenn Nachrichten keine *SessionId-, PartitionKey-* oder *MessageId*-Eigenschaft enthalten, ordnet Service Bus die Nachrichten den Fragmenten sequenziell zu.</span><span class="sxs-lookup"><span data-stu-id="cb256-284">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="cb256-285">Wenn ein Fragment nicht verfügbar ist, geht Service Bus zum nächsten über.</span><span class="sxs-lookup"><span data-stu-id="cb256-285">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="cb256-286">Dies bedeutet, dass ein vorübergehender Fehler in der Nachrichteninfrastruktur nicht dazu führt, dass der Nachrichtensendevorgang nicht ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="cb256-286">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="cb256-287">Beachten Sie die folgende Punkte, wenn Sie entscheiden, ob und wie Sie eine Service Bus-Nachrichtenwarteschlange oder ein Service Bus-Topic partitionieren:</span><span class="sxs-lookup"><span data-stu-id="cb256-287">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

- <span data-ttu-id="cb256-288">Service Bus-Warteschlangen und -Themen werden im Umfang des Service Bus-Namespace erstellt.</span><span class="sxs-lookup"><span data-stu-id="cb256-288">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="cb256-289">Service Bus erlaubt derzeit bis zu 100 partitionierte Warteschlangen oder Themen pro Namespace.</span><span class="sxs-lookup"><span data-stu-id="cb256-289">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>

- <span data-ttu-id="cb256-290">Jeder Service Bus-Namespace setzt Kontingente für die verfügbaren Ressourcen fest, wie z. B. die Anzahl der Abonnements pro Topic, die Anzahl gleichzeitiger Sende- und Empfangsanforderungen und die maximale Anzahl gleichzeitiger Verbindungen, die aufgebaut werden können.</span><span class="sxs-lookup"><span data-stu-id="cb256-290">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="cb256-291">Diese Kontingente sind unter [Service Bus-Kontingente] dokumentiert.</span><span class="sxs-lookup"><span data-stu-id="cb256-291">These quotas are documented in [Service Bus quotas].</span></span> <span data-ttu-id="cb256-292">Wenn Sie diese Werte überschreiten möchten, dann erstellen Sie zusätzliche Namespaces mit ihren eigenen Warteschlangen und Themen und verteilen Sie die Arbeit auf diese Namespaces.</span><span class="sxs-lookup"><span data-stu-id="cb256-292">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="cb256-293">Erstellen Sie z. B. in einer globalen Anwendung separate Namespaces in jeder Region und konfigurieren Sie die Anwendungsinstanzen so, dass sie die Warteschlangen und Themen in nächstliegendem Namespace verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb256-293">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>

- <span data-ttu-id="cb256-294">Nachrichten, die als Teil einer Transaktion gesendet werden, müssen einen Partitionsschlüssel angeben.</span><span class="sxs-lookup"><span data-stu-id="cb256-294">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="cb256-295">Dies kann eine *SessionId*-, *PartitionKey*- oder *MessageId*-Eigenschaft sein.</span><span class="sxs-lookup"><span data-stu-id="cb256-295">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="cb256-296">Alle Nachrichten, die als Teil derselben Transaktion gesendet werden, müssen denselben Partitionsschlüssel angeben, da sie vom selben Nachrichtenbroker-Prozess verarbeitet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="cb256-296">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="cb256-297">Sie können keine Nachrichten an verschiedene Warteschlangen oder Themen innerhalb der gleichen Transaktion senden.</span><span class="sxs-lookup"><span data-stu-id="cb256-297">You cannot send messages to different queues or topics within the same transaction.</span></span>

- <span data-ttu-id="cb256-298">Partitionierte Warteschlangen und Topics können nicht so konfiguriert werden, dass sie im Leerlauf automatisch gelöscht werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-298">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>

- <span data-ttu-id="cb256-299">Partitionierte Warteschlangen und Topics können zurzeit nicht mit dem Advanced Message Queuing Protocol (AMQP) verwendet werden, wenn Sie plattformübergreifende oder hybride Lösungen erstellen.</span><span class="sxs-lookup"><span data-stu-id="cb256-299">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-cosmos-db"></a><span data-ttu-id="cb256-300">Partitionieren von Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="cb256-300">Partitioning Cosmos DB</span></span>

<span data-ttu-id="cb256-301">Azure Cosmos DB ist eine NoSQL-Datenbank, für die JSON-Dokumente mit der [SQL-API von Azure Cosmos DB][cosmosdb-sql-api] gespeichert werden können.</span><span class="sxs-lookup"><span data-stu-id="cb256-301">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="cb256-302">Ein Dokument in einer Cosmos DB-Datenbank ist eine JSON-serialisierte Darstellung eines Objekts oder sonstigen Datensegments.</span><span class="sxs-lookup"><span data-stu-id="cb256-302">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="cb256-303">Es werden keine festgelegten Schemen erzwungen, außer dass jedes Dokument über eine eindeutige ID verfügen muss.</span><span class="sxs-lookup"><span data-stu-id="cb256-303">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="cb256-304">Dokumente werden in Auflistungen organisiert.</span><span class="sxs-lookup"><span data-stu-id="cb256-304">Documents are organized into collections.</span></span> <span data-ttu-id="cb256-305">In einer Sammlung können Sie verwandte Dokumente gruppieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-305">You can group related documents together in a collection.</span></span> <span data-ttu-id="cb256-306">Beispielsweise könnten Sie in einem System, das Blogbeiträge verwaltet, den Inhalt jedes Blogbeitrags als Dokument in einer Sammlung speichern.</span><span class="sxs-lookup"><span data-stu-id="cb256-306">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="cb256-307">Sie können auch Sammlungen für jeden Thementyp erstellen.</span><span class="sxs-lookup"><span data-stu-id="cb256-307">You can also create collections for each subject type.</span></span> <span data-ttu-id="cb256-308">Alternativ dazu könnten Sie in einer mehrinstanzenfähigen Anwendung, wie beispielsweise einem System, in dem verschiedene Autoren ihre eigenen Blogbeiträge kontrollieren und verwalten können, Blogs nach Autor partitionieren und für jeden Autor eine separate Sammlung erstellen.</span><span class="sxs-lookup"><span data-stu-id="cb256-308">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="cb256-309">Der Speicherplatz, der Sammlungen zugeordnet ist, ist elastisch und kann je nach Bedarf schrumpfen oder wachsen.</span><span class="sxs-lookup"><span data-stu-id="cb256-309">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="cb256-310">Cosmos DB unterstützt die automatische Partitionierung von Daten basierend auf einem anwendungsdefinierten Partitionsschlüssel.</span><span class="sxs-lookup"><span data-stu-id="cb256-310">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="cb256-311">Eine *logische Partition* ist eine Partition, die alle Daten für einen einzelnen Partitionsschlüsselwert speichert.</span><span class="sxs-lookup"><span data-stu-id="cb256-311">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="cb256-312">Alle Dokumente, die den gleichen Wert für den Partitionsschlüssel besitzen, werden in der gleichen logischen Partition platziert.</span><span class="sxs-lookup"><span data-stu-id="cb256-312">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="cb256-313">Cosmos DB verteilt Werte anhand des Hash des Partitionsschlüssels.</span><span class="sxs-lookup"><span data-stu-id="cb256-313">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="cb256-314">Eine logische Partition hat eine maximale Größe von 10 GB.</span><span class="sxs-lookup"><span data-stu-id="cb256-314">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="cb256-315">Daher ist die Auswahl des Partitionsschlüssels eine wichtige Entscheidung, die zur Entwurfszeit getroffen wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-315">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="cb256-316">Wählen Sie eine Eigenschaft mit einer Vielzahl von Werten und gleichmäßigen Zugriffsmustern.</span><span class="sxs-lookup"><span data-stu-id="cb256-316">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="cb256-317">Weitere Informationen finden Sie unter [Partitionieren und Skalieren in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span><span class="sxs-lookup"><span data-stu-id="cb256-317">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="cb256-318">Jede Cosmos DB-Datenbank weist eine bestimmte *Leistungsebene* auf, mit der der Umfang der Ressourcen festgelegt wird, die von der Datenbank genutzt werden können.</span><span class="sxs-lookup"><span data-stu-id="cb256-318">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="cb256-319">Jeder Leistungsstufe ist eine Ratenbegrenzung für *Anforderungseinheiten* (Request Unit, RU) zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="cb256-319">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="cb256-320">Die RU-Ratenbegrenzung gibt die Menge der Ressourcen an, die für diese Sammlung reserviert sind und für die ausschließliche Verwendung durch diese Sammlung zur Verfügung stehen.</span><span class="sxs-lookup"><span data-stu-id="cb256-320">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="cb256-321">Die Kosten einer Sammlung richten sich nach der Leistungsstufe, die für diese Sammlung gewählt wurde.</span><span class="sxs-lookup"><span data-stu-id="cb256-321">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="cb256-322">Je höher die Leistungsstufe (und die RU-Ratenbegrenzung), desto höher die Kosten.</span><span class="sxs-lookup"><span data-stu-id="cb256-322">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="cb256-323">Sie können die Leistungsstufe einer Sammlung über das Azure-Portal anpassen.</span><span class="sxs-lookup"><span data-stu-id="cb256-323">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="cb256-324">Weitere Informationen finden Sie unter [Anforderungseinheiten in Azure Cosmos DB][cosmos-db-ru].</span><span class="sxs-lookup"><span data-stu-id="cb256-324">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>

<span data-ttu-id="cb256-325">Falls der Partitionierungsmechanismus von Cosmos DB nicht ausreicht, müssen die Daten unter Umständen auf der Anwendungsebene horizontal partitioniert werden (Sharding).</span><span class="sxs-lookup"><span data-stu-id="cb256-325">If the partitioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="cb256-326">Dokumentsammlungen bieten einen natürlichen Mechanismus zum Partitionieren von Daten innerhalb einer Einzeldatenbank.</span><span class="sxs-lookup"><span data-stu-id="cb256-326">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="cb256-327">Der einfachste Weg Sharding zu implementieren, ist für jedes Shard eine Auflistung zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="cb256-327">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="cb256-328">Container sind logische Ressourcen und können einen oder mehrere Server umfassen.</span><span class="sxs-lookup"><span data-stu-id="cb256-328">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="cb256-329">Container mit fester Größe weisen eine Obergrenze von 10 GB und 10.000 RUs/Sek. (Request Units, Anforderungseinheiten) auf.</span><span class="sxs-lookup"><span data-stu-id="cb256-329">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="cb256-330">Für unbegrenzte Container gilt keine maximale Speichergröße, sie müssen aber einen Partitionsschlüssel angeben.</span><span class="sxs-lookup"><span data-stu-id="cb256-330">Unlimited containers do not have a maximum storage size, but must specify a partition key.</span></span> <span data-ttu-id="cb256-331">Bei Anwendungs-Sharding muss die Clientanwendung Anforderungen an den geeigneten Shard leiten. Für gewöhnlich erfolgt dies durch Implementieren ihres eigenen Zuordnungsmechanismus, basierend auf einigen Attributen der Daten, die den Shardschlüssel definieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-331">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span>

<span data-ttu-id="cb256-332">Alle Datenbanken werden im Kontext eines Cosmos DB-Datenbankkontos erstellt.</span><span class="sxs-lookup"><span data-stu-id="cb256-332">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="cb256-333">Ein einzelnes Konto kann mehrere Datenbanken enthalten und gibt an, in welcher Region die Datenbanken erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-333">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="cb256-334">Jedes Konto erzwingt auch seine eigene Zugriffssteuerung.</span><span class="sxs-lookup"><span data-stu-id="cb256-334">Each account also enforces its own access control.</span></span> <span data-ttu-id="cb256-335">Sie können Cosmos DB-Konten verwenden, um Shards (Sammlungen in Datenbanken) geografisch in der Nähe der Benutzer zu platzieren, die darauf zugreifen müssen, und Einschränkungen erzwingen, sodass nur diese Benutzer eine Verbindung damit herstellen können.</span><span class="sxs-lookup"><span data-stu-id="cb256-335">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="cb256-336">Berücksichtigen Sie die folgenden Punkte bei der Entscheidung, wie Daten mit der SQL-API von Azure Cosmos DB partitioniert werden sollen:</span><span class="sxs-lookup"><span data-stu-id="cb256-336">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

- <span data-ttu-id="cb256-337">**Die für eine Cosmos DB-Datenbank verfügbaren Ressourcen unterliegen den Kontingentgrenzen für das Konto.**</span><span class="sxs-lookup"><span data-stu-id="cb256-337">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="cb256-338">Jede Datenbank kann eine Reihe von Sammlungen enthalten, und jeder Sammlung ist eine Leistungsebene zugeordnet, die die RU-Ratenbegrenzung (reservierter Durchsatz) für diese Sammlung regelt.</span><span class="sxs-lookup"><span data-stu-id="cb256-338">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="cb256-339">Weitere Informationen finden Sie unter [Grenzwerte für Azure-Abonnements, -Dienste und -Kontingente sowie allgemeine Beschränkungen][azure-limits].</span><span class="sxs-lookup"><span data-stu-id="cb256-339">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>

- <span data-ttu-id="cb256-340">**Jedes Dokument muss über ein Attribut verfügen, das verwendet werden kann, um das Dokument in der Sammlung, in der es enthalten ist, eindeutig zu identifizieren**.</span><span class="sxs-lookup"><span data-stu-id="cb256-340">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="cb256-341">Dieses Attribut unterscheidet sich vom Shardschlüssel, der die Sammlung definiert, in der das Dokument enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-341">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="cb256-342">Eine Sammlung kann eine große Anzahl von Dokumenten enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-342">A collection can contain a large number of documents.</span></span> <span data-ttu-id="cb256-343">Theoretisch besteht die einzige Einschränkung in der maximalen Länge der Dokument-ID.</span><span class="sxs-lookup"><span data-stu-id="cb256-343">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="cb256-344">Die Dokument-ID kann bis zu 255 Zeichen lang sein.</span><span class="sxs-lookup"><span data-stu-id="cb256-344">The document ID can be up to 255 characters.</span></span>

- <span data-ttu-id="cb256-345">**Alle Vorgänge für ein Dokument werden im Kontext einer Transaktion ausgeführt. Transaktionen sind auf die Sammlung begrenzt, in der das Dokument enthalten ist.**</span><span class="sxs-lookup"><span data-stu-id="cb256-345">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="cb256-346">Wenn ein Vorgang fehlschlägt, wird die Arbeit, die durch ihn ausgeführt wurde, zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="cb256-346">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="cb256-347">Während ein Vorgang für ein Dokument ausgeführt wird, unterliegen alle vorgenommenen Änderungen einer Isolierung auf Snapshotebene.</span><span class="sxs-lookup"><span data-stu-id="cb256-347">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="cb256-348">Wenn z. B. eine Anforderung zum Erstellen eines neuen Dokuments fehlschlägt, stellt dieser Mechanismus sicher, dass einem anderen Benutzer, der die Datenbank gleichzeitig abfragt, kein Teildokument angezeigt wird, das dann entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-348">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>

- <span data-ttu-id="cb256-349">**Datenbankabfragen sind ebenfalls auf die Sammlungsebene begrenzt**.</span><span class="sxs-lookup"><span data-stu-id="cb256-349">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="cb256-350">Eine einzelne Abfrage kann nur Daten aus einer Sammlung abrufen.</span><span class="sxs-lookup"><span data-stu-id="cb256-350">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="cb256-351">Wenn Sie Daten aus mehreren Sammlungen abrufen müssen, müssen Sie jede Sammlung einzeln abfragen und die Ergebnisse in Ihrem Anwendungscode zusammenführen.</span><span class="sxs-lookup"><span data-stu-id="cb256-351">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>

- <span data-ttu-id="cb256-352">**Cosmos DB-Datenbanken unterstützen programmierbare Elemente, die alle zusammen mit Dokumenten in einer Sammlung gespeichert werden können.**</span><span class="sxs-lookup"><span data-stu-id="cb256-352">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="cb256-353">Hierzu gehören gespeicherte Prozeduren, benutzerdefinierte Funktionen und Trigger (geschrieben in JavaScript).</span><span class="sxs-lookup"><span data-stu-id="cb256-353">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="cb256-354">Diese Elemente können auf alle Dokumente in der gleichen Auflistung zugreifen.</span><span class="sxs-lookup"><span data-stu-id="cb256-354">These items can access any document within the same collection.</span></span> <span data-ttu-id="cb256-355">Außerdem werden diese Elemente entweder im Rahmen der Ambient-Transaktion ausgeführt (im Fall eines Triggers, der als Ergebnis eines für ein Dokument ausgeführten Erstellungs-, Lösch- oder Ersetzungsvorgangs ausgelöst wird) oder durch Starten einer neuen Transaktion (im Fall einer gespeicherten Prozedur, die als Ergebnis einer expliziten Clientanforderung ausgeführt wird).</span><span class="sxs-lookup"><span data-stu-id="cb256-355">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="cb256-356">Wenn der Code in einem programmierbaren Element eine Ausnahme auslöst, wird für die Transaktion ein Rollback ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="cb256-356">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="cb256-357">Sie können gespeicherte Prozeduren und Trigger verwenden, um die Integrität und Konsistenz zwischen den Dokumenten zu verwalten, aber diese Dokumente müssen alle derselben Auflistung angehören.</span><span class="sxs-lookup"><span data-stu-id="cb256-357">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>

- <span data-ttu-id="cb256-358">**Die Sammlungen, die Sie in den Datenbanken speichern möchten, sollten die von den Leistungsstufen der Sammlungen definierten Durchsatzgrenzen nicht überschreiten**.</span><span class="sxs-lookup"><span data-stu-id="cb256-358">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="cb256-359">Weitere Informationen finden Sie unter [Anforderungseinheiten in Azure Cosmos DB][cosmos-db-ru].</span><span class="sxs-lookup"><span data-stu-id="cb256-359">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="cb256-360">Wenn diese Grenzwerte bei Ihnen voraussichtlich erreicht werden, sollten Sie erwägen, die Sammlungen auf Datenbanken in verschiedenen Konten zu verteilen, um die Last pro Sammlung zu verringern.</span><span class="sxs-lookup"><span data-stu-id="cb256-360">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-azure-search"></a><span data-ttu-id="cb256-361">Partitionieren von Azure Search</span><span class="sxs-lookup"><span data-stu-id="cb256-361">Partitioning Azure Search</span></span>

<span data-ttu-id="cb256-362">Die Fähigkeit, nach Daten zu suchen, ist häufig die primäre Navigations- und Untersuchungsmethode, die von vielen Webanwendungen bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-362">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="cb256-363">Damit können Benutzer Ressourcen anhand einer Kombination verschiedener Suchkriterien schnell finden (beispielsweise Produkte in einer E-Commerce-Anwendung).</span><span class="sxs-lookup"><span data-stu-id="cb256-363">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="cb256-364">Azure Search bietet Volltext-Suchfunktionen über Web-Inhalte und umfasst Funktionen wie z. B. Type-ahead, vorgeschlagene Abfragen basierend auf Übereinstimmungen und Facettennavigation.</span><span class="sxs-lookup"><span data-stu-id="cb256-364">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="cb256-365">Weitere Informationen finden Sie unter [Was ist Azure Search?].</span><span class="sxs-lookup"><span data-stu-id="cb256-365">For more information, see [What is Azure Search?].</span></span>

<span data-ttu-id="cb256-366">Azure Search speichert durchsuchbare Inhalte in Form von JSON-Dokumenten in einer Datenbank.</span><span class="sxs-lookup"><span data-stu-id="cb256-366">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="cb256-367">Sie definieren Indizes, um die durchsuchbaren Felder in diesen Dokumenten anzugeben, und stellen diese Definitionen Azure Search zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="cb256-367">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="cb256-368">Wenn ein Benutzer eine Suchanforderung sendet, verwendet Azure Search die entsprechenden Indizes, um übereinstimmende Elemente zu finden.</span><span class="sxs-lookup"><span data-stu-id="cb256-368">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="cb256-369">Um Konflikte zu reduzieren, kann der von Azure Search verwendete Speicher in 1, 2, 3, 4, 6 oder 12 Partitionen unterteilt werden, von denen jede bis zu 6-mal repliziert werden kann.</span><span class="sxs-lookup"><span data-stu-id="cb256-369">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="cb256-370">Das Produkt der Multiplikation aus Anzahl von Partitionen und Anzahl von Replikaten wird *Sucheinheit* (Search Unit, SU) genannt.</span><span class="sxs-lookup"><span data-stu-id="cb256-370">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="cb256-371">Eine einzelne Instanz von Azure Search kann maximal 36 SUs enthalten (eine Datenbank mit 12 Partitionen unterstützt nur maximal 3 Replikate).</span><span class="sxs-lookup"><span data-stu-id="cb256-371">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="cb256-372">Jede SU, die Ihrem Dienst zugeordnet wird, wird Ihnen berechnet.</span><span class="sxs-lookup"><span data-stu-id="cb256-372">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="cb256-373">Wenn die Menge an durchsuchbaren Inhalten oder die Rate der Suchanforderungen wächst, können Sie einer vorhandenen Azure Search-Instanz SUs hinzufügen, um die zusätzliche Last zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="cb256-373">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="cb256-374">Azure Search selbst verteilt die Dokumente gleichmäßig über die Partitionen.</span><span class="sxs-lookup"><span data-stu-id="cb256-374">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="cb256-375">Zurzeit werden keine manuellen Partitionierungsstrategien unterstützt.</span><span class="sxs-lookup"><span data-stu-id="cb256-375">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="cb256-376">Jede Partition kann maximal 15 Millionen Dokumente enthalten oder 300 GB Speicherplatz belegen (je nachdem, welche Menge geringer ist).</span><span class="sxs-lookup"><span data-stu-id="cb256-376">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="cb256-377">Sie können bis zu 50 Indizes generieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-377">You can create up to 50 indexes.</span></span> <span data-ttu-id="cb256-378">Die Leistung des Diensts variiert und ist abhängig von der Komplexität der Dokumente, den verfügbaren Indizes und den Auswirkungen von Netzwerklatenz.</span><span class="sxs-lookup"><span data-stu-id="cb256-378">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="cb256-379">Im Durchschnitt sollte ein einzelnes Replikat (1 SU) 15 Abfragen pro Sekunde (Queries Per Second, QPS) verarbeiten können. Es empfiehlt sich allerdings, ein Benchmarking mit Ihren eigenen Daten durchzuführen, um ein genaueres Maß für den Durchsatz zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-379">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="cb256-380">Weitere Informationen finden Sie unter [Grenzwerte für den Azure Search-Dienst].</span><span class="sxs-lookup"><span data-stu-id="cb256-380">For more information, see [Service limits in Azure Search].</span></span>

> [!NOTE]
> <span data-ttu-id="cb256-381">Sie können eine begrenzte Anzahl von Datentypen in durchsuchbaren Dokumenten speichern, z. B. Zeichenfolgen, boolesche Werte, numerische Daten, Datums-/Uhrzeitdaten und einige geografische Daten.</span><span class="sxs-lookup"><span data-stu-id="cb256-381">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="cb256-382">Weitere Informationen finden Sie auf der Microsoft-Website im Artikel [Unterstützte Datentypen (Azure Search)].</span><span class="sxs-lookup"><span data-stu-id="cb256-382">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>

<span data-ttu-id="cb256-383">Sie können die Art und Weise, in der Azure Search Daten für jede Instanz des Diensts partitioniert, nur in begrenztem Umfang steuern.</span><span class="sxs-lookup"><span data-stu-id="cb256-383">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="cb256-384">In einer globalen Umgebung können Sie jedoch möglicherweise die Leistung verbessern sowie Latenz und Konflikte verringern, indem Sie den Dienst selbst mithilfe einer der folgenden Strategien partitionieren:</span><span class="sxs-lookup"><span data-stu-id="cb256-384">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

- <span data-ttu-id="cb256-385">Erstellen Sie eine Instanz von Azure Search in jeder geografischen Region, und stellen Sie sicher, dass Clientanwendungen an die nächste verfügbare Instanz geleitet werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-385">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="cb256-386">Diese Strategie erfordert, dass alle Aktualisierungen von durchsuchbarem Inhalt für alle Instanzen des Dienstes rechtzeitig repliziert werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-386">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>

- <span data-ttu-id="cb256-387">Erstellen Sie zwei Ebenen von Azure Search:</span><span class="sxs-lookup"><span data-stu-id="cb256-387">Create two tiers of Azure Search:</span></span>

  - <span data-ttu-id="cb256-388">Einen lokalen Dienst in jeder Region, der die Daten enthält, auf die Benutzer in dieser Region am häufigsten zugreifen.</span><span class="sxs-lookup"><span data-stu-id="cb256-388">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="cb256-389">Benutzer können auf dieser Ebene suchen, um schnelle, aber eingeschränkte Ergebnisse zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-389">Users can direct requests here for fast but limited results.</span></span>
  - <span data-ttu-id="cb256-390">Einen globalen Dienst, der alle Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="cb256-390">A global service that encompasses all the data.</span></span> <span data-ttu-id="cb256-391">Benutzer können auf dieser Ebene suchen, um langsamere, aber vollständigere Ergebnisse zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-391">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="cb256-392">Dieser Ansatz ist besonders geeignet, wenn erhebliche regionale Unterschiede in Bezug auf die gesuchten Daten vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="cb256-392">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-azure-redis-cache"></a><span data-ttu-id="cb256-393">Partitionieren von Azure Redis Cache</span><span class="sxs-lookup"><span data-stu-id="cb256-393">Partitioning Azure Redis Cache</span></span>

<span data-ttu-id="cb256-394">Azure Redis Cache bietet einen Shared Caching Service in der Cloud, der auf dem Redis-Schlüssel-Wert-Datenspeicher basiert.</span><span class="sxs-lookup"><span data-stu-id="cb256-394">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="cb256-395">Wie der Name schon sagt, ist Azure Redis Cache als Cachinglösung konzipiert.</span><span class="sxs-lookup"><span data-stu-id="cb256-395">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="cb256-396">Verwenden Sie den Cache nur zur vorübergehenden Speicherung, nicht als permanenten Datenspeicher.</span><span class="sxs-lookup"><span data-stu-id="cb256-396">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="cb256-397">Anwendungen, die Azure Redis Cache verwenden, sollten weiterhin funktionieren, auch wenn der Cache nicht verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-397">Applications that utilize Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="cb256-398">Azure Redis Cache unterstützt die primäre/sekundäre Replikation zur Gewährleistung von Hochverfügbarkeit, derzeit ist die maximale Cachegröße jedoch auf 53 GB beschränkt.</span><span class="sxs-lookup"><span data-stu-id="cb256-398">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="cb256-399">Wenn mehr Speicherplatz benötigt wird, müssen Sie zusätzliche Caches erstellen.</span><span class="sxs-lookup"><span data-stu-id="cb256-399">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="cb256-400">Weitere Informationen finden Sie unter [Azure Redis Cache].</span><span class="sxs-lookup"><span data-stu-id="cb256-400">For more information, see [Azure Redis Cache].</span></span>

<span data-ttu-id="cb256-401">Die Partitionierung eines Redis-Datenspeichers umfasst das Aufteilen von Daten über Instanzen des Redis-Diensts hinweg.</span><span class="sxs-lookup"><span data-stu-id="cb256-401">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="cb256-402">Jede Instanz stellt eine einzelne Partition dar.</span><span class="sxs-lookup"><span data-stu-id="cb256-402">Each instance constitutes a single partition.</span></span> <span data-ttu-id="cb256-403">Azure Redis Cache abstrahiert die Redis-Dienste hinter einer Fassade und zeigt sie nicht direkt an.</span><span class="sxs-lookup"><span data-stu-id="cb256-403">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="cb256-404">Die einfachste Methode zum Implementieren der Partitionierung ist es, mehrere Azure Redis Cache-Instanzen zu erstellen und die Daten auf diese Instanzen zu verteilen.</span><span class="sxs-lookup"><span data-stu-id="cb256-404">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="cb256-405">Sie können jedem Datenelement einen Bezeichner (Partitionsschlüssel) zuordnen, der angibt, in welchem Cache es gespeichert ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-405">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="cb256-406">Die Logik der Clientanwendung kann diesen Bezeichner dann zum Weiterleiten von Anforderungen an die entsprechende Partition verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb256-406">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="cb256-407">Dieses Schema ist sehr einfach, aber wenn sich das Partitionierungsschema ändert (z. B. durch Erstellen zusätzlicher Azure Redis Cache-Instanzen), müssen Clientanwendungen möglicherweise neu konfiguriert werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-407">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="cb256-408">Systemeigene Redis (nicht Azure Redis Cache) unterstützt die serverseitige Partitionierung basierend auf Redis-Clustering.</span><span class="sxs-lookup"><span data-stu-id="cb256-408">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="cb256-409">Bei diesem Ansatz können Sie die Daten mit einem Hashmechanismus gleichmäßig auf die Server verteilen.</span><span class="sxs-lookup"><span data-stu-id="cb256-409">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="cb256-410">Jeder Redis-Server speichert Metadaten, die den Bereich der Hash-Schlüssel beschreiben, die die Partition enthält, und enthält außerdem Informationen dazu, welche Hash-Schlüssel sich in den Partitionen auf anderen Servern befinden.</span><span class="sxs-lookup"><span data-stu-id="cb256-410">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="cb256-411">Clientanwendungen senden Anforderungen einfach an einen der teilnehmenden Redis-Server (wahrscheinlich an den nächstgelegenen).</span><span class="sxs-lookup"><span data-stu-id="cb256-411">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="cb256-412">Der Redis-Server überprüft die Clientanforderung.</span><span class="sxs-lookup"><span data-stu-id="cb256-412">The Redis server examines the client request.</span></span> <span data-ttu-id="cb256-413">Wenn die Anforderung lokal aufgelöst werden kann, führt der Redis-Server den angeforderten Vorgang aus.</span><span class="sxs-lookup"><span data-stu-id="cb256-413">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="cb256-414">Andernfalls leitet er die Anforderung an den geeigneten Server weiter.</span><span class="sxs-lookup"><span data-stu-id="cb256-414">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="cb256-415">Dieses Modell wird mithilfe von Redis-Clustering implementiert und wird ausführlicher im [Redis-Cluster-Lernprogramm] auf der Redis-Website beschrieben.</span><span class="sxs-lookup"><span data-stu-id="cb256-415">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="cb256-416">Redis-Clustering ist für Clientanwendungen transparent.</span><span class="sxs-lookup"><span data-stu-id="cb256-416">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="cb256-417">Dem Cluster können zusätzliche Redis-Server hinzugefügt (und die Daten neu partitioniert) werden, ohne dass die Clients neu konfiguriert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="cb256-417">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="cb256-418">Azure Redis Cache unterstützt derzeit kein Redis-Clustering.</span><span class="sxs-lookup"><span data-stu-id="cb256-418">Azure Redis Cache does not currently support Redis clustering.</span></span> <span data-ttu-id="cb256-419">Wenn Sie diesen Ansatz mit Azure umsetzen möchten, müssen Sie Ihre eigenen Redis-Server implementieren, indem Sie Redis auf einem Satz virtueller Azure-Computer installieren und diese manuell konfigurieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-419">If you want to implement this approach with Azure, then you must implement your own Redis servers by installing Redis on a set of Azure virtual machines and configuring them manually.</span></span> <span data-ttu-id="cb256-420">Im Blog [Running Redis on a CentOS Linux VM in Azure] (Ausführen von Redis auf einer CentOS-Linux-VM in Azure) finden Sie ein Beispiel für die Erstellung und Konfiguration eines Redis-Knotens, der als virtueller Azure-Computer ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-420">The page [Running Redis on a CentOS Linux VM in Azure] walks through an example that shows you how to build and configure a Redis node running as an Azure VM.</span></span>

<span data-ttu-id="cb256-421">Weitere Informationen zur Implementierung der Partitionierung mit Redis finden Sie auf der Redis-Website unter [Partitioning: how to split data among multiple Redis instances] (Partitionierung: Aufteilen von Daten auf mehrere Redis-Instanzen).</span><span class="sxs-lookup"><span data-stu-id="cb256-421">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="cb256-422">Im restlichen Abschnitt wird davon ausgegangen, dass Sie clientseitige oder Proxy-unterstützte Partitionierung implementieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-422">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="cb256-423">Berücksichtigen Sie folgende Punkte bei der Entscheidung, wie Daten mit Azure Redis Cache partitioniert werden sollen:</span><span class="sxs-lookup"><span data-stu-id="cb256-423">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

- <span data-ttu-id="cb256-424">Azure Redis Cache ist nicht als dauerhafter Datenspeicher gedacht, d. h. unabhängig vom Partitionierungsschema, das Sie implementieren, muss Ihr Anwendungscode Daten aus anderen Speicherorten als dem Cache abrufen können.</span><span class="sxs-lookup"><span data-stu-id="cb256-424">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>

- <span data-ttu-id="cb256-425">Daten, auf die häufig zugegriffen wird, sollten in derselben Partition gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-425">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="cb256-426">Redis ist ein leistungsfähiger Schlüssel-Wert-Speicher, der mehrere in hohem Maß optimierte Mechanismen zum Strukturieren von Daten bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="cb256-426">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="cb256-427">Bei diesen Mechanismen kann es sich um folgende handeln:</span><span class="sxs-lookup"><span data-stu-id="cb256-427">These mechanisms can be one of the following:</span></span>
  - <span data-ttu-id="cb256-428">Einfache Zeichenfolgen (binäre Daten mit einer Länge von bis zu 512 MB)</span><span class="sxs-lookup"><span data-stu-id="cb256-428">Simple strings (binary data up to 512 MB in length)</span></span>
  - <span data-ttu-id="cb256-429">Aggregierte Datentypen wie beispielsweise Listen (die als Warteschlangen und Stapel fungieren können)</span><span class="sxs-lookup"><span data-stu-id="cb256-429">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  - <span data-ttu-id="cb256-430">Sätze (sortiert und nicht sortiert)</span><span class="sxs-lookup"><span data-stu-id="cb256-430">Sets (ordered and unordered)</span></span>
  - <span data-ttu-id="cb256-431">Hashes (die verwandte Felder gruppieren können, wie z. B. die Elemente, die die Felder in einem Objekt repräsentieren)</span><span class="sxs-lookup"><span data-stu-id="cb256-431">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>

- <span data-ttu-id="cb256-432">Mithilfe der aggregierten Datentypen können Sie viele ähnliche Werte mit dem gleichen Schlüssel verknüpfen.</span><span class="sxs-lookup"><span data-stu-id="cb256-432">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="cb256-433">Ein Redis-Schlüssel identifiziert eine Liste, einen Satz oder einen Hash anstatt der darin enthaltenen Datenelemente.</span><span class="sxs-lookup"><span data-stu-id="cb256-433">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="cb256-434">All diese Datentypen sind mit Azure Redis Cache verfügbar und werden auf der Redis-Website unter [Datentypen] (Datentypen) beschrieben.</span><span class="sxs-lookup"><span data-stu-id="cb256-434">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="cb256-435">Beispielsweise können in dem Teil eines E-Commerce-Systems, in dem die Bestellungen von Kunden verfolgt werden, die Details der einzelnen Kunden in einem Redis-Hash gespeichert werden, der mithilfe der Kunden-ID verschlüsselt wurde.</span><span class="sxs-lookup"><span data-stu-id="cb256-435">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="cb256-436">Jeder Hash kann eine Sammlung von Bestellnummern für den jeweiligen Kunden enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-436">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="cb256-437">Ein separater Redis-Satz kann die Bestellungen enthalten, die wieder als Hashes strukturiert sind und mithilfe der Bestellnummer verschlüsselt wurden.</span><span class="sxs-lookup"><span data-stu-id="cb256-437">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="cb256-438">Abbildung 8 zeigt eine solche Struktur.</span><span class="sxs-lookup"><span data-stu-id="cb256-438">Figure 8 shows this structure.</span></span> <span data-ttu-id="cb256-439">Beachten Sie, dass Redis keine Form der referenziellen Integrität implementiert, daher ist es die Verantwortung des Entwicklers, die Beziehungen zwischen Kunden und Bestellungen zu verwalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-439">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![Vorgeschlagene Struktur im Redis-Speicher für die Aufzeichnung von Bestellungen und Informationen von Kunden](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="cb256-441">*Abbildung 8: Vorgeschlagene Struktur im Redis-Speicher zur Erfassung von Kundenbestellungen und -informationen*</span><span class="sxs-lookup"><span data-stu-id="cb256-441">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details.*</span></span>

> [!NOTE]
> <span data-ttu-id="cb256-442">In Redis sind alle Schlüssel binäre Datenwerte (wie Redis-Zeichenfolgen) und können bis zu 512 MB Daten enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-442">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="cb256-443">Theoretisch kann ein Schlüssel nahezu jegliche Informationen enthalten.</span><span class="sxs-lookup"><span data-stu-id="cb256-443">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="cb256-444">Es empfiehlt sich jedoch, eine konsistente Benennungskonvention für Schlüssel anzuwenden, die den Datentyp beschreibt und die Entität identifiziert, aber nicht übermäßig lang ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-444">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="cb256-445">Eine gängige Methode ist die Verwendung von Schlüsseln im Format „Entitätstyp:ID“.</span><span class="sxs-lookup"><span data-stu-id="cb256-445">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="cb256-446">Beispielsweise können Sie „Kunde:99“ verwenden, um den Schlüssel für einen Kunden mit der ID 99 anzugeben.</span><span class="sxs-lookup"><span data-stu-id="cb256-446">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>

- <span data-ttu-id="cb256-447">Sie können die vertikale Partitionierung durch das Speichern von verwandten Informationen in anderen Aggregationen in derselben Datenbank implementieren.</span><span class="sxs-lookup"><span data-stu-id="cb256-447">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="cb256-448">Sie können z. B. in einer E-Commerce-Anwendung häufig abgerufene Informationen zu Produkten in einem Redis-Hash speichern und weniger häufig verwendete Detailinformationen in einem anderen.</span><span class="sxs-lookup"><span data-stu-id="cb256-448">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span> <span data-ttu-id="cb256-449">Beide Hashes können die gleiche Produkt-ID als Teil des Schlüssels verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb256-449">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="cb256-450">Sie können z.B. „Produkt:*nn*“ für die allgemeinen Produktinformationen (*nn* ist die Produkt-ID) und „Produktdetails:*nn*“ für die Detailinformationen verwenden.</span><span class="sxs-lookup"><span data-stu-id="cb256-450">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="cb256-451">Mit dieser Strategie lässt sich die Datenmenge reduzieren, die bei den meisten Abfragen wahrscheinlich abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-451">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>

- <span data-ttu-id="cb256-452">Sie können einen Redis-Datenspeicher neu partitionieren, denken Sie jedoch daran, dass dies eine komplexe und zeitaufwendige Aufgabe ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-452">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="cb256-453">Redis-Clustering kann Daten automatisch neu partitionieren, diese Funktion ist allerdings mit Azure Redis Cache nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="cb256-453">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="cb256-454">Daher sollten Sie beim Entwerfen Ihres Partitionierungsschemas für ausreichend freien Speicherplatz in jeder Partition sorgen, um den langfristig zu erwartenden Datenzuwachs zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="cb256-454">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="cb256-455">Denken Sie jedoch daran, dass Azure Redis Cache zur vorübergehenden Zwischenspeicherung von Daten vorgesehen ist, und dass im Cache gehaltene Daten eine begrenzte Lebensdauer haben, die als Time-to-live (TTL) Wert angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-455">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="cb256-456">Für relativ flüchtige Daten sollte der TTL-Wert klein, für statische Daten kann er jedoch wesentlich größer sein.</span><span class="sxs-lookup"><span data-stu-id="cb256-456">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="cb256-457">Vermeiden Sie die Speicherung großer Mengen langlebiger Daten im Cache, wenn die Datenmenge wahrscheinlich den kompletten Cache belegen wird.</span><span class="sxs-lookup"><span data-stu-id="cb256-457">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="cb256-458">Sie können eine Entfernungsrichtlinie angeben, die bewirkt, dass Azure Redis Cache die Daten entfernt, wenn der Speicherplatz knapp bemessen ist.</span><span class="sxs-lookup"><span data-stu-id="cb256-458">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="cb256-459">Wenn Sie Azure Redis Cache verwenden, können Sie durch Auswahl des entsprechenden Tarifs die maximale Größe des Caches (von 250 MB bis 53 GB) angeben.</span><span class="sxs-lookup"><span data-stu-id="cb256-459">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="cb256-460">Sie können einen Azure Redis Cache jedoch nach dem Erstellen nicht vergrößern (oder verkleinern).</span><span class="sxs-lookup"><span data-stu-id="cb256-460">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>

- <span data-ttu-id="cb256-461">Redis-Batches und -Transaktionen können sich nicht über mehrere Verbindungen erstrecken, d. h. alle Daten, die von einem Batch- oder Transaktionsvorgang betroffen sind, sollten in der gleichen Datenbank (Shard) gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-461">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="cb256-462">Eine Abfolge von Operationen in einer Redis-Transaktion ist nicht unbedingt atomar.</span><span class="sxs-lookup"><span data-stu-id="cb256-462">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="cb256-463">Die Befehle, die eine Transaktion bilden, werden vor der Ausführung überprüft und in eine Warteschlange eingereiht.</span><span class="sxs-lookup"><span data-stu-id="cb256-463">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="cb256-464">Wenn während dieser Phase ein Fehler auftritt, wird die gesamte Warteschlange verworfen.</span><span class="sxs-lookup"><span data-stu-id="cb256-464">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="cb256-465">Nachdem die Transaktion jedoch erfolgreich übermittelt wurde, werden die Befehle in der Warteschlange der Reihenfolge nach ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="cb256-465">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="cb256-466">Wenn bei einem Befehl ein Fehler auftritt, wird nur die Ausführung dieses Befehls beendet.</span><span class="sxs-lookup"><span data-stu-id="cb256-466">If any command fails, only that command stops running.</span></span> <span data-ttu-id="cb256-467">Alle vorherigen und nachfolgenden Befehle in der Warteschlange werden ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="cb256-467">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="cb256-468">Weitere Informationen finden Sie auf der Redis-Website unter [Transaktionen].</span><span class="sxs-lookup"><span data-stu-id="cb256-468">For more information, go to the [Transactions] page on the Redis website.</span></span>

- <span data-ttu-id="cb256-469">Redis unterstützt eine begrenzte Anzahl von atomischen Vorgängen.</span><span class="sxs-lookup"><span data-stu-id="cb256-469">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="cb256-470">Die einzige Vorgänge dieser Art, die mehrere Schlüssel und Werte unterstützen, sind MGET und MSET.</span><span class="sxs-lookup"><span data-stu-id="cb256-470">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="cb256-471">MGET-Vorgänge geben eine Auflistung von Werten für eine angegebene Liste von Schlüsseln zurück, und MSET-Vorgänge speichern eine Auflistung von Werten für eine angegebene Liste von Schlüsseln.</span><span class="sxs-lookup"><span data-stu-id="cb256-471">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="cb256-472">Wenn Sie diese Vorgänge verwenden müssen, müssen die Schlüssel-Wert-Paare, auf die durch die MSET- und MGET-Befehle verwiesen wird, in derselben Datenbank gespeichert sein.</span><span class="sxs-lookup"><span data-stu-id="cb256-472">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-azure-service-fabric"></a><span data-ttu-id="cb256-473">Partitionieren von Azure Service Fabric</span><span class="sxs-lookup"><span data-stu-id="cb256-473">Partitioning Azure Service Fabric</span></span>

<span data-ttu-id="cb256-474">Azure Service Fabric ist eine Microservice-Plattform, die eine Laufzeit für verteilte Anwendungen in der Cloud bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="cb256-474">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="cb256-475">Service Fabric unterstützt ausführbare .NET-Gastanwendungsdateien, zustandsbehaftete und zustandslose Dienste sowie Container.</span><span class="sxs-lookup"><span data-stu-id="cb256-475">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="cb256-476">Für zustandsbehaftete Dienste wird eine [Reliable Collection][service-fabric-reliable-collections] bereitgestellt, um Daten im Service Fabric-Cluster in einer Schlüssel-Wert-Sammlung dauerhaft zu speichern.</span><span class="sxs-lookup"><span data-stu-id="cb256-476">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="cb256-477">Weitere Informationen zu Strategien für die Partitionierung von Schlüsseln in einer Reliable Collection finden Sie unter [Richtlinien und Empfehlungen für Reliable Collections in Azure Service Fabric].</span><span class="sxs-lookup"><span data-stu-id="cb256-477">For more information about strategies for partitioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="cb256-478">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="cb256-478">More information</span></span>

- <span data-ttu-id="cb256-479">Der Artikel [Übersicht über Azure Service Fabric] enthält eine Einführung in Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="cb256-479">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>

- <span data-ttu-id="cb256-480">[Partitionieren von Service Fabric Reliable Services] enthält weitere Informationen zu Reliable Services in Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="cb256-480">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-azure-event-hubs"></a><span data-ttu-id="cb256-481">Partitionieren von Azure Event Hubs</span><span class="sxs-lookup"><span data-stu-id="cb256-481">Partitioning Azure Event Hubs</span></span>

<span data-ttu-id="cb256-482">[Azure Event Hubs][event-hubs] ist für das Datenstreaming in großem Umfang ausgelegt, und die Partitionierung ist in den Dienst integriert, um die horizontale Skalierung zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="cb256-482">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="cb256-483">Jeder Consumer liest nur eine bestimmte Partition des Nachrichtendatenstroms.</span><span class="sxs-lookup"><span data-stu-id="cb256-483">Each consumer only reads a specific partition of the message stream.</span></span>

<span data-ttu-id="cb256-484">Dem Ereignisherausgeber ist nur der Partitionsschlüssel bekannt, nicht die Partition, auf der die Ereignisse veröffentlicht werden.</span><span class="sxs-lookup"><span data-stu-id="cb256-484">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="cb256-485">Dieses Entkoppeln von Schlüssel und Partition entbindet den Absender davon, zu viel über die Downstreamverarbeitung wissen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="cb256-485">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="cb256-486">(Es ist auch möglich, Ereignisse direkt an eine bestimmte Partition zu senden, aber normalerweise ist dies nicht zu empfehlen.)</span><span class="sxs-lookup"><span data-stu-id="cb256-486">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="cb256-487">Berücksichtigen Sie bei der Wahl der Anzahl von Partitionen die langfristigen Skalierungsanforderungen.</span><span class="sxs-lookup"><span data-stu-id="cb256-487">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="cb256-488">Nach der Erstellung eines Event Hub können Sie die Anzahl von Partitionen nicht mehr ändern.</span><span class="sxs-lookup"><span data-stu-id="cb256-488">After an event hub is created, you can't change the number of partitions.</span></span>

<span data-ttu-id="cb256-489">Weitere Informationen zur Verwendung von Partitionen in Event Hubs finden Sie unter [Was ist Event Hubs?].</span><span class="sxs-lookup"><span data-stu-id="cb256-489">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="cb256-490">Informationen zu den Kompromissen, die in Bezug auf die Verfügbarkeit und die Konsistenz gemacht werden müssen, finden Sie unter [Verfügbarkeit und Konsistenz in Event Hubs].</span><span class="sxs-lookup"><span data-stu-id="cb256-490">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

[Verfügbarkeit und Konsistenz in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis Cache]: https://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Azure-Speichertabelle – Entwurfshandbuch]: /azure/storage/storage-table-design-guide
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer]: https://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Datentypen]: https://redis.io/topics/data-types
[Data Types]: https://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Richtlinien und Empfehlungen für Reliable Collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Übersicht über Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[Partitionieren von Service Fabric Reliable Services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partitioning: how to split data among multiple Redis instances]: https://redis.io/topics/partitioning
[Ausführen von Entitätsgruppentransaktionen]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Performing Entity Group Transactions]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Redis-Cluster-Lernprogramm]: https://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: https://redis.io/topics/cluster-tutorial
[Running Redis on a CentOS Linux VM in Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Service Bus-Kontingente]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Grenzwerte für den Azure Search-Dienst]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding pattern]: ../patterns/sharding.md
[Unterstützte Datentypen (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Transaktionen]: https://redis.io/topics/transactions
[Transactions]: https://redis.io/topics/transactions
[Was ist Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[Was ist Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[Skalierbarkeitsziele]: /azure/storage/common/storage-scalability-targets
[scalability targets]: /azure/storage/common/storage-scalability-targets
