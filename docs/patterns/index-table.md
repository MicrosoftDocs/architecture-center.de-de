---
title: Indextabelle
description: Erstellen von Indizes für die Felder im Datenspeicher, auf die häufig von Abfragen verwiesen wird
keywords: Entwurfsmuster
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- data-management
- performance-scalability
ms.openlocfilehash: 24a1061349af84d13f05f88a1698b4efe4b0f449
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/14/2017
ms.locfileid: "24541784"
---
# <a name="index-table-pattern"></a><span data-ttu-id="ad51a-104">Muster „Indextabelle“</span><span class="sxs-lookup"><span data-stu-id="ad51a-104">Index Table pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="ad51a-105">Erstellen Sie Indizes für die Felder im Datenspeicher, auf die häufig von Abfragen verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="ad51a-105">Create indexes over the fields in data stores that are frequently referenced by queries.</span></span> <span data-ttu-id="ad51a-106">Dieses Muster kann die Abfrageleistung verbessern, indem es Anwendungen das schnellere Auffinden der Daten, die aus einem Datenspeicher abgerufen werden sollen, ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="ad51a-106">This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="ad51a-107">Kontext und Problem</span><span class="sxs-lookup"><span data-stu-id="ad51a-107">Context and problem</span></span>

<span data-ttu-id="ad51a-108">Viele Datenspeicher organisieren die Daten für eine Sammlung von Entitäten unter Verwendung des Primärschlüssels.</span><span class="sxs-lookup"><span data-stu-id="ad51a-108">Many data stores organize the data for a collection of entities using the primary key.</span></span> <span data-ttu-id="ad51a-109">Mit diesem Schlüssel kann eine Anwendung Daten suchen und abrufen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-109">An application can use this key to locate and retrieve data.</span></span> <span data-ttu-id="ad51a-110">Die Abbildung zeigt ein Beispiel für einen Datenspeicher, der Kundeninformationen enthält.</span><span class="sxs-lookup"><span data-stu-id="ad51a-110">The figure shows an example of a data store holding customer information.</span></span> <span data-ttu-id="ad51a-111">Bei dem Primärschlüssel handelt es sich um die Kunden-ID.</span><span class="sxs-lookup"><span data-stu-id="ad51a-111">The primary key is the Customer ID.</span></span> <span data-ttu-id="ad51a-112">Die Abbildung zeigt die nach Primärschlüssel (Kunden-ID) organisierten Kundeninformationen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-112">The figure shows customer information organized by the primary key (Customer ID).</span></span>

![Abbildung 1: Nach Primärschlüssel (Kunden-ID) organisierte Kundeninformationen](./_images/index-table-figure-1.png)


<span data-ttu-id="ad51a-114">Der Primärschlüssel ist zwar für Abfragen nützlich, die Daten basierend auf dem Wert dieses Schlüssels abrufen, eine Anwendung kann den Primärschlüssel möglicherweise jedoch nicht verwenden, wenn sie Daten basierend auf einem anderen Feld abrufen muss.</span><span class="sxs-lookup"><span data-stu-id="ad51a-114">While the primary key is valuable for queries that fetch data based on the value of this key, an application might not be able to use the primary key if it needs to retrieve data based on some other field.</span></span> <span data-ttu-id="ad51a-115">Im Beispiel mit den Kundendaten kann eine Anwendung keine Kunden mithilfe der als Primärschlüssel dienenden Kunden-ID abrufen, wenn Daten ausschließlich über den Wert eines anderen Attributs abfragt werden (z.B. der Stadt, in der der Kunde ansässig ist).</span><span class="sxs-lookup"><span data-stu-id="ad51a-115">In the customers example, an application can't use the Customer ID primary key to retrieve customers if it queries data solely by referencing the value of some other attribute, such as the town in which the customer is located.</span></span> <span data-ttu-id="ad51a-116">Um eine solche Abfrage durchzuführen, muss die Anwendung möglicherweise jeden Kundendatensatz abrufen und untersuchen, was sich als langwieriger Prozess erweisen kann.</span><span class="sxs-lookup"><span data-stu-id="ad51a-116">To perform a query such as this, the application might have to fetch and examine every customer record, which could be a slow process.</span></span>

<span data-ttu-id="ad51a-117">Viele Managementsysteme für relationale Datenbanken unterstützen sekundäre Indizes.</span><span class="sxs-lookup"><span data-stu-id="ad51a-117">Many relational database management systems support secondary indexes.</span></span> <span data-ttu-id="ad51a-118">Ein sekundärer Index ist eine separate Datenstruktur, die nach einem oder mehreren Feldern für andere Schlüssel als Primärschlüssel (Sekundärschlüssel) organisiert ist, und weist darauf hin, wo die Daten für die einzelnen indizierten Werte gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-118">A secondary index is a separate data structure that's organized by one or more nonprimary (secondary) key fields, and it indicates where the data for each indexed value is stored.</span></span> <span data-ttu-id="ad51a-119">Die Elemente in einem sekundären Index werden in der Regel nach dem Wert der Sekundärschlüssel sortiert, um eine schnelle Suche nach Daten zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-119">The items in a secondary index are typically sorted by the value of the secondary keys to enable fast lookup of data.</span></span> <span data-ttu-id="ad51a-120">Diese Indizes werden in der Regel automatisch vom Datenbankmanagementsystem verwaltet.</span><span class="sxs-lookup"><span data-stu-id="ad51a-120">These indexes are usually maintained automatically by the database management system.</span></span>

<span data-ttu-id="ad51a-121">Sie können beliebig viele sekundäre Indizes erstellen, um die verschiedenen von Ihrer Anwendung durchgeführten Abfragen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-121">You can create as many secondary indexes as you need to support the different queries that your application performs.</span></span> <span data-ttu-id="ad51a-122">Beispielsweise ist es in einer Tabelle mit Kundendaten in einer relationalen Datenbank, in der die Kunden-ID als Primärschlüssel dient, vorteilhaft, einen sekundären Index über das Feld „Town“ hinzuzufügen, wenn die Anwendung häufig anhand des Wohnsitzes nach Kunden sucht.</span><span class="sxs-lookup"><span data-stu-id="ad51a-122">For example, in a Customers table in a relational database where the Customer ID is the primary key, it's beneficial to add a secondary index over the town field if the application frequently looks up customers by the town where they reside.</span></span>

<span data-ttu-id="ad51a-123">Obwohl Sekundärindizes in relationalen Systemen weit verbreitet sind, bieten die meisten von Cloudanwendungen verwendeten NoSQL-Datenspeicher keine vergleichbare Funktion.</span><span class="sxs-lookup"><span data-stu-id="ad51a-123">However, although secondary indexes are common in relational systems, most NoSQL data stores used by cloud applications don't provide an equivalent feature.</span></span>

## <a name="solution"></a><span data-ttu-id="ad51a-124">Lösung</span><span class="sxs-lookup"><span data-stu-id="ad51a-124">Solution</span></span>

<span data-ttu-id="ad51a-125">Wenn der Datenspeicher keine Sekundärindizes unterstützt, können Sie diese manuell emulieren, indem Sie eigene Indextabellen erstellen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-125">If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables.</span></span> <span data-ttu-id="ad51a-126">Eine Indextabelle organisiert die Daten nach einem bestimmten Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="ad51a-126">An index table organizes the data by a specified key.</span></span> <span data-ttu-id="ad51a-127">Für die Strukturierung einer Indextabelle werden üblicherweise drei Strategien angewendet, je nachdem, wie viele Sekundärindizes benötigt werden und welche Arten von Abfragen von einer Anwendung durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-127">Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</span></span>

<span data-ttu-id="ad51a-128">Die erste Strategie besteht darin, die Daten in jeder Indextabelle zu duplizieren, aber nach verschiedenen Schlüsseln zu organisieren (vollständige Denormalisierung).</span><span class="sxs-lookup"><span data-stu-id="ad51a-128">The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization).</span></span> <span data-ttu-id="ad51a-129">Die folgende Abbildung zeigt Indextabellen, die die gleichen Kundeninformationen nach den Attributen „Town“ und „LastName“ organisiert.</span><span class="sxs-lookup"><span data-stu-id="ad51a-129">The next figure shows index tables that organize the same customer information by Town and LastName.</span></span>

![Abbildung 2: Duplizieren von Daten in jeder Indextabelle](./_images/index-table-figure-2.png)


<span data-ttu-id="ad51a-131">Diese Strategie ist sinnvoll, wenn die Daten im Verhältnis zur Anzahl der Abfragen, die mit den einzelnen Schlüsseln durchgeführt werden, relativ statisch sind.</span><span class="sxs-lookup"><span data-stu-id="ad51a-131">This strategy is appropriate if the data is relatively static compared to the number of times it's queried using each key.</span></span> <span data-ttu-id="ad51a-132">Wenn die Daten dynamischer sind, wird der Verarbeitungsaufwand für die Verwaltung der einzelnen Indextabellen zu groß, als dass dieser Ansatz sinnvoll wäre.</span><span class="sxs-lookup"><span data-stu-id="ad51a-132">If the data is more dynamic, the processing overhead of maintaining each index table becomes too large for this approach to be useful.</span></span> <span data-ttu-id="ad51a-133">Zudem ist bei einem sehr großen Datenvolumen der Speicherplatzbedarf für die Speicherung der doppelten Daten beträchtlich.</span><span class="sxs-lookup"><span data-stu-id="ad51a-133">Also, if the volume of data is very large, the amount of space required to store the duplicate data is significant.</span></span>

<span data-ttu-id="ad51a-134">Die zweite Strategie besteht darin, normalisierte, nach verschiedenen Schlüsseln organisierte Indextabellen zu erstellen und mithilfe des Primärschlüssels auf die Originaldaten zu verweisen, anstatt sie zu duplizieren, wie in der folgenden Abbildung gezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="ad51a-134">The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure.</span></span> <span data-ttu-id="ad51a-135">Die Originaldaten werden als „Faktentabelle“ bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="ad51a-135">The original data is called a fact table.</span></span>

![Abbildung 3: Von den einzelnen Indextabellen referenzierte Daten](./_images/index-table-figure-3.png)


<span data-ttu-id="ad51a-137">Diese Methode spart Speicherplatz und reduziert den Aufwand für die Verwaltung doppelter Daten.</span><span class="sxs-lookup"><span data-stu-id="ad51a-137">This technique saves space and reduces the overhead of maintaining duplicate data.</span></span> <span data-ttu-id="ad51a-138">Der Nachteil ist, dass eine Anwendung zwei Suchvorgänge durchführen muss, um Daten mithilfe eines Sekundärschlüssels zu suchen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-138">The disadvantage is that an application has to perform two lookup operations to find data using a secondary key.</span></span> <span data-ttu-id="ad51a-139">Sie muss den Primärschlüssel für die Daten in der Indextabelle suchen und die Daten dann mithilfe des Primärschlüssels in der Faktentabelle nachschlagen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-139">It has to find the primary key for the data in the index table, and then use the primary key to look up the data in the fact table.</span></span>

<span data-ttu-id="ad51a-140">Die dritte Strategie besteht darin, teilweise normalisierte Indextabellen – organisiert nach verschiedenen Schlüsseln – zu erstellen, die häufig abgerufene Felder duplizieren.</span><span class="sxs-lookup"><span data-stu-id="ad51a-140">The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields.</span></span> <span data-ttu-id="ad51a-141">Verweisen Sie auf die Faktentabelle, um auf seltener verwendete Felder zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-141">Reference the fact table to access less frequently accessed fields.</span></span> <span data-ttu-id="ad51a-142">Die folgende Abbildung zeigt, wie häufig verwendete Daten in den einzelnen Indextabellen dupliziert werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-142">The next figure shows how commonly accessed data is duplicated in each index table.</span></span>

![Abbildung 4: In den einzelnen Indextabellen duplizierte häufig verwendete Daten](./_images/index-table-figure-4.png)


<span data-ttu-id="ad51a-144">Diese Strategie ist der goldene Mittelweg zwischen den ersten beiden Vorgehensweisen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-144">With this strategy, you can strike a balance between the first two approaches.</span></span> <span data-ttu-id="ad51a-145">Die Daten für häufige Abfragen können durch einen einzigen Suchvorgang schnell abgerufen werden, wobei der Speicherplatzbedarf und Verwaltungsaufwand nicht so hoch ausfallen wie bei der Duplizierung des gesamten Datasets.</span><span class="sxs-lookup"><span data-stu-id="ad51a-145">The data for common queries can be retrieved quickly by using a single lookup, while the space and maintenance overhead isn't as significant as duplicating the entire data set.</span></span>

<span data-ttu-id="ad51a-146">Wenn eine Anwendung häufig durch eine Kombination von Werten Daten abfragt (z.B. „Finde alle Kunden, die in Redmond leben und mit Nachnamen „Smith“ heißen“), können Sie die Schlüssel für die Elemente in der Indextabelle als Verkettung des Town- und LastName-Attributs implementieren.</span><span class="sxs-lookup"><span data-stu-id="ad51a-146">If an application frequently queries data by specifying a combination of values (for example, “Find all customers that live in Redmond and that have a last name of Smith”), you could implement the keys to the items in the index table as a concatenation of the Town attribute and the LastName attribute.</span></span> <span data-ttu-id="ad51a-147">Die folgende Abbildung zeigt eine Indextabelle basierend auf zusammengesetzten Schlüsseln.</span><span class="sxs-lookup"><span data-stu-id="ad51a-147">The next figure shows an index table based on composite keys.</span></span> <span data-ttu-id="ad51a-148">Sortiert werden die Schlüssel nach dem Town-Attribut und bei Datensätzen, die den gleichen Wert für das Town-Attribut enthalten, dann nach dem LastName-Attribut.</span><span class="sxs-lookup"><span data-stu-id="ad51a-148">The keys are sorted by Town, and then by LastName for records that have the same value for Town.</span></span>

![Abbildung 5: Eine auf zusammengesetzten Schlüsseln basierende Indextabelle](./_images/index-table-figure-5.png)


<span data-ttu-id="ad51a-150">Indextabellen können Abfragevorgänge durch in Shards unterteilte Daten beschleunigen und sind besonders nützlich, wenn der Shardschlüssel mit Hashes versehen ist.</span><span class="sxs-lookup"><span data-stu-id="ad51a-150">Index tables can speed up query operations over sharded data, and are especially useful where the shard key is hashed.</span></span> <span data-ttu-id="ad51a-151">Die folgende Abbildung zeigt ein Beispiel, bei dem der Shardschlüssel einen Hash der Kunden-ID darstellt.</span><span class="sxs-lookup"><span data-stu-id="ad51a-151">The next figure shows an example where the shard key is a hash of the Customer ID.</span></span> <span data-ttu-id="ad51a-152">Die Indextabelle kann die Daten nach dem Wert ohne Hash (Town und LastName) organisieren und den Shardschlüssel mit Hash als Suchdaten zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-152">The index table can organize data by the nonhashed value (Town and LastName), and provide the hashed shard key as the lookup data.</span></span> <span data-ttu-id="ad51a-153">Dies erspart der Anwendung das wiederholte Berechnen von Hashschlüsseln (ein kostspieliger Vorgang), wenn sie Daten innerhalb eines Bereichs abrufen oder in der Reihenfolge des Schlüssels ohne Hash abrufen muss.</span><span class="sxs-lookup"><span data-stu-id="ad51a-153">This can save the application from repeatedly calculating hash keys (an expensive operation) if it needs to retrieve data that falls within a range, or it needs to fetch data in order of the nonhashed key.</span></span> <span data-ttu-id="ad51a-154">Beispielsweise kann eine Abfrage wie „Finde alle Kunden, die in Redmond leben“ schnell gelöst werden, indem die entsprechenden Elemente in der Indextabelle, in der alle Elemente in einem zusammenhängenden Block gespeichert sind, gesucht werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-154">For example, a query such as “Find all customers that live in Redmond” can be quickly resolved by locating the matching items in the index table, where they're all stored in a contiguous block.</span></span> <span data-ttu-id="ad51a-155">Folgen Sie dann mithilfe der in der Indextabelle gespeicherten Shardschlüssel den Verweisen auf die Kundendaten.</span><span class="sxs-lookup"><span data-stu-id="ad51a-155">Then, follow the references to the customer data using the shard keys stored in the index table.</span></span>

![Abbildung 6: Indextabelle für schnelle Suchvorgänge nach Daten in Shards](./_images/index-table-figure-6.png)


## <a name="issues-and-considerations"></a><span data-ttu-id="ad51a-157">Probleme und Überlegungen</span><span class="sxs-lookup"><span data-stu-id="ad51a-157">Issues and considerations</span></span>

<span data-ttu-id="ad51a-158">Beachten Sie die folgenden Punkte bei der Entscheidung, wie dieses Muster implementiert werden soll:</span><span class="sxs-lookup"><span data-stu-id="ad51a-158">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="ad51a-159">Der Aufwand für die Verwaltung von Sekundärindizes kann enorm sein.</span><span class="sxs-lookup"><span data-stu-id="ad51a-159">The overhead of maintaining secondary indexes can be significant.</span></span> <span data-ttu-id="ad51a-160">Sie müssen die Abfragen, die Ihre Anwendung verwendet, analysieren und verstehen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-160">You must analyze and understand the queries that your application uses.</span></span> <span data-ttu-id="ad51a-161">Erstellen Sie Indextabellen nur dann, wenn diese aller Wahrscheinlichkeit nach regelmäßig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-161">Only create index tables when they're likely to be used regularly.</span></span> <span data-ttu-id="ad51a-162">Erstellen Sie keine Indextabellen für hypothetische Fälle, um Abfragen zu unterstützen, die eine Anwendung nicht oder nur gelegentlich ausführt.</span><span class="sxs-lookup"><span data-stu-id="ad51a-162">Don't create speculative index tables to support queries that an application doesn't perform, or performs only occasionally.</span></span>
- <span data-ttu-id="ad51a-163">Durch das Duplizieren von Daten in einer Indextabelle können sich die Gemeinkosten in Bezug auf den Speicher und den Aufwand für die Verwaltung mehrerer Datenkopien signifikant erhöhen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-163">Duplicating data in an index table can add significant overhead in storage costs and the effort required to maintain multiple copies of data.</span></span>
- <span data-ttu-id="ad51a-164">Um eine Indextabelle als normalisierte Struktur zu implementieren, die auf die Originaldaten verweist, muss eine Anwendung für die Datensuche zwei Suchvorgänge durchführen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-164">Implementing an index table as a normalized structure that references the original data requires an application to perform two lookup operations to find data.</span></span> <span data-ttu-id="ad51a-165">Der erste Vorgang durchsucht die Indextabelle, um den Primärschlüssel abzurufen, während der zweite Vorgang den Primärschlüssel zum Abrufen der Daten verwendet.</span><span class="sxs-lookup"><span data-stu-id="ad51a-165">The first operation searches the index table to retrieve the primary key, and the second uses the primary key to fetch the data.</span></span>
- <span data-ttu-id="ad51a-166">Wenn ein System mehrere Indextabellen in verschiedenen sehr großen Datasets enthält, kann es schwierig sein, die Konsistenz zwischen Indextabellen und den Originaldaten aufrechtzuerhalten.</span><span class="sxs-lookup"><span data-stu-id="ad51a-166">If a system incorporates a number of index tables over very large data sets, it can be difficult to maintain consistency between index tables and the original data.</span></span> <span data-ttu-id="ad51a-167">Die Anwendung kann eventuell nach dem Modell der letztlichen Konsistenz entworfen werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-167">It might be possible to design the application around the eventual consistency model.</span></span> <span data-ttu-id="ad51a-168">Um beispielsweise Daten einzufügen, zu aktualisieren oder zu löschen, könnte eine Anwendung eine Nachricht in eine Warteschlange einreihen. Anschließend könnte sie einen separaten Task den Vorgang durchführen und die Indextabellen, die auf diese Daten asynchron verweisen, verwalten lassen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-168">For example, to insert, update, or delete data, an application could post a message to a queue and let a separate task perform the operation and maintain the index tables that reference this data asynchronously.</span></span> <span data-ttu-id="ad51a-169">Weitere Informationen zum Implementieren von letztlicher Konsistenz finden Sie unter [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) (Grundlagen der Datenkonsistenz).</span><span class="sxs-lookup"><span data-stu-id="ad51a-169">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

   >  <span data-ttu-id="ad51a-170">Microsoft Azure-Speichertabellen unterstützen transaktionale Updates für Änderungen an Daten in derselben Partition (als „Entitätsgruppentransaktionen“ bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="ad51a-170">Microsoft Azure storage tables support transactional updates for changes made to data held in the same partition (referred to as entity group transactions).</span></span> <span data-ttu-id="ad51a-171">Wenn Sie die Daten für eine Faktentabelle und eine oder mehrere Indextabellen in derselben Partition speichern können, können Sie mithilfe dieser Funktion Konsistenz gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="ad51a-171">If you can store the data for a fact table and one or more index tables in the same partition, you can use this feature to help ensure consistency.</span></span>

- <span data-ttu-id="ad51a-172">Indextabellen können selbst partitioniert oder mit Shards konfiguriert sein.</span><span class="sxs-lookup"><span data-stu-id="ad51a-172">Index tables might themselves be partitioned or sharded.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="ad51a-173">Verwendung dieses Musters</span><span class="sxs-lookup"><span data-stu-id="ad51a-173">When to use this pattern</span></span>

<span data-ttu-id="ad51a-174">Verwenden Sie dieses Muster, um die Abfrageleistung zu verbessern, wenn eine Anwendung häufig mit einem anderen Schlüssel als den Primärschlüssel (bzw. Shardschlüssel) Daten abrufen muss.</span><span class="sxs-lookup"><span data-stu-id="ad51a-174">Use this pattern to improve query performance when an application frequently needs to retrieve data by using a key other than the primary (or shard) key.</span></span>

<span data-ttu-id="ad51a-175">Dieses Muster ist in folgenden Fällen möglicherweise nicht geeignet:</span><span class="sxs-lookup"><span data-stu-id="ad51a-175">This pattern might not be useful when:</span></span>

- <span data-ttu-id="ad51a-176">Bei den Daten handelt es sich um temporäre Daten.</span><span class="sxs-lookup"><span data-stu-id="ad51a-176">Data is volatile.</span></span> <span data-ttu-id="ad51a-177">Eine Indextabelle kann sehr schnell veraltet sein, wodurch sie ineffizient wird oder der Aufwand für die Verwaltung der Indextabelle die durch die Verwendung der Indextabelle erzielten Einsparungen übersteigt.</span><span class="sxs-lookup"><span data-stu-id="ad51a-177">An index table can become out of date very quickly, making it ineffective or making the overhead of maintaining the index table greater than any savings made by using it.</span></span>
- <span data-ttu-id="ad51a-178">Ein Feld, das als Sekundärschlüssel für eine Indextabelle ausgewählt wurde, ist nicht unterscheidend und kann nur eine kleine Menge von Werten (z.B. Geschlecht) enthalten.</span><span class="sxs-lookup"><span data-stu-id="ad51a-178">A field selected as the secondary key for an index table is nondiscriminating and can only have a small set of values (for example, gender).</span></span>
- <span data-ttu-id="ad51a-179">Die Datenwerte für ein Feld, das als Sekundärschlüssel für eine Indextabelle ausgewählt wurde, sind unterschiedlich verteilt.</span><span class="sxs-lookup"><span data-stu-id="ad51a-179">The balance of the data values for a field selected as the secondary key for an index table are highly skewed.</span></span> <span data-ttu-id="ad51a-180">Wenn z.B. 90 % der Datensätze den gleichen Wert in einem Feld enthalten, kann die Erstellung und Verwaltung einer Indextabelle zum Nachschlagen von Daten basierend auf diesem Feld mit einem größeren Aufwand verbunden sein als das sequentielle Durchsuchen der Daten.</span><span class="sxs-lookup"><span data-stu-id="ad51a-180">For example, if 90% of the records contain the same value in a field, then creating and maintaining an index table to look up data based on this field might create more overhead than scanning sequentially through the data.</span></span> <span data-ttu-id="ad51a-181">Wenn sehr häufig Werte in den verbleibenden 10 % der Datensätze abgefragt werden, kann sich dieser Index dagegen als nützlich erweisen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-181">However, if queries very frequently target values that lie in the remaining 10%, this index can be useful.</span></span> <span data-ttu-id="ad51a-182">Daher sollten Sie sich bewusst machen, welche Abfragen und wie häufig diese von Ihrer Anwendung ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-182">You should understand the queries that your application is performing, and how frequently they're performed.</span></span>

## <a name="example"></a><span data-ttu-id="ad51a-183">Beispiel</span><span class="sxs-lookup"><span data-stu-id="ad51a-183">Example</span></span>

<span data-ttu-id="ad51a-184">Azure-Speichertabellen stellen einen hochgradig skalierbaren Schlüssel-/Wertdatenspeicher für Anwendungen bereit, die in der Cloud ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-184">Azure storage tables provide a highly scalable key/value data store for applications running in the cloud.</span></span> <span data-ttu-id="ad51a-185">Anwendungen speichern und rufen Datenwerte durch Angabe eines Schlüssels ab.</span><span class="sxs-lookup"><span data-stu-id="ad51a-185">Applications store and retrieve data values by specifying a key.</span></span> <span data-ttu-id="ad51a-186">Die Datenwerte können mehrere Felder enthalten, doch die Struktur eines Datenelements ist für einen Tabellenspeicher opak, der ein Datenelement einfach als Array von Bytes verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="ad51a-186">The data values can contain multiple fields, but the structure of a data item is opaque to table storage, which simply handles a data item as an array of bytes.</span></span>

<span data-ttu-id="ad51a-187">Azure-Speichertabellen unterstützen auch Sharding.</span><span class="sxs-lookup"><span data-stu-id="ad51a-187">Azure storage tables also support sharding.</span></span> <span data-ttu-id="ad51a-188">Der Shardingschlüssel enthält zwei Elemente: einen Partitionsschlüssel und einen Zeilenschlüssel.</span><span class="sxs-lookup"><span data-stu-id="ad51a-188">The sharding key includes two elements, a partition key and a row key.</span></span> <span data-ttu-id="ad51a-189">Elemente mit dem gleichen Partitionsschlüssel werden in der gleichen Partition (Shard) gespeichert und in einem Shard in der Reihenfolge der Zeilenschlüssel gespeichert.</span><span class="sxs-lookup"><span data-stu-id="ad51a-189">Items that have the same partition key are stored in the same partition (shard), and the items are stored in row key order within a shard.</span></span> <span data-ttu-id="ad51a-190">Der Tabellenspeicher ist für die Ausführung von Abfragen optimiert, die Daten in einem zusammenhängenden Bereich von Zeilenschlüsselwerten innerhalb einer Partition abrufen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-190">Table storage is optimized for performing queries that fetch data falling within a contiguous range of row key values within a partition.</span></span> <span data-ttu-id="ad51a-191">Wenn Sie Cloudanwendungen erstellen, die Informationen in Azure-Tabellen speichern, sollten Sie Ihre Daten unter Berücksichtigung dieses Features strukturieren.</span><span class="sxs-lookup"><span data-stu-id="ad51a-191">If you're building cloud applications that store information in Azure tables, you should structure your data with this feature in mind.</span></span>

<span data-ttu-id="ad51a-192">Sehen wir uns zum Beispiel eine Anwendung an, die Informationen über Filme speichert.</span><span class="sxs-lookup"><span data-stu-id="ad51a-192">For example, consider an application that stores information about movies.</span></span> <span data-ttu-id="ad51a-193">Die Anwendung fragt Filme häufig nach Genre ab (Action, Dokumentarfilm, historischer Film, Komödie, Drama etc.).</span><span class="sxs-lookup"><span data-stu-id="ad51a-193">The application frequently queries movies by genre (action, documentary, historical, comedy, drama, and so on).</span></span> <span data-ttu-id="ad51a-194">Sie könnten eine Azure-Tabelle mit Partitionen für jedes Genre erstellen, indem Sie das Genre als Partitionsschlüssel verwenden und den Filmnamen als Zeilenschlüssel angeben, wie in der folgende Abbildung gezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="ad51a-194">You could create an Azure table with partitions for each genre by using the genre as the partition key, and specifying the movie name as the row key, as shown in the next figure.</span></span>

![Abbildung 7: In einer Azure-Tabelle gespeicherte Filmdaten](./_images/index-table-figure-7.png)


<span data-ttu-id="ad51a-196">Diese Vorgehensweise ist nicht sehr effizient, wenn die Anwendung auch Filme nach Darstellern abfragen muss.</span><span class="sxs-lookup"><span data-stu-id="ad51a-196">This approach is less effective if the application also needs to query movies by starring actor.</span></span> <span data-ttu-id="ad51a-197">In diesem Fall können Sie eine separate Azure-Tabelle erstellen, die als Indextabelle fungiert.</span><span class="sxs-lookup"><span data-stu-id="ad51a-197">In this case, you can create a separate Azure table that acts as an index table.</span></span> <span data-ttu-id="ad51a-198">Als Partitionsschlüssel dient der Darsteller und als Zeilenschlüssel der Filmname.</span><span class="sxs-lookup"><span data-stu-id="ad51a-198">The partition key is the actor and the row key is the movie name.</span></span> <span data-ttu-id="ad51a-199">Die Daten für jeden Darsteller werden in separaten Partitionen gespeichert.</span><span class="sxs-lookup"><span data-stu-id="ad51a-199">The data for each actor will be stored in separate partitions.</span></span> <span data-ttu-id="ad51a-200">Wenn ein Film mehrere Darsteller enthält, wird derselbe Film in mehreren Partitionen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="ad51a-200">If a movie stars more than one actor, the same movie will occur in multiple partitions.</span></span>

<span data-ttu-id="ad51a-201">Sie können die Filmdaten in den Werten der einzelnen Partitionen duplizieren, indem Sie die im oben beschriebenen Abschnitt „Lösung“ erste Vorgehensweise befolgen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-201">You can duplicate the movie data in the values held by each partition by adopting the first approach described in the Solution section above.</span></span> <span data-ttu-id="ad51a-202">Da jeder Film jedoch wahrscheinlich mehrmals repliziert wird (einmal pro Darsteller), kann es effizienter sein, die Daten teilweise zu denormalisieren, um die gängigsten Abfragen (z.B. für die Namen der anderen Darsteller) zu unterstützen. Zudem sollte eine Anwendung alle verbleibenden Details abrufen können, indem sie den Partitionsschlüssel verwendet, der für die Suche nach vollständigen Informationen in den Genrepartitionen notwendig ist.</span><span class="sxs-lookup"><span data-stu-id="ad51a-202">However, it's likely that each movie will be replicated several times (once for each actor), so it might be more efficient to partially denormalize the data to support the most common queries (such as the names of the other actors) and enable an application to retrieve any remaining details by including the partition key necessary to find the complete information in the genre partitions.</span></span> <span data-ttu-id="ad51a-203">Diese Vorgehensweise wird durch die dritte Option im Abschnitt „Lösung“ beschrieben.</span><span class="sxs-lookup"><span data-stu-id="ad51a-203">This approach is described by the third option in the Solution section.</span></span> <span data-ttu-id="ad51a-204">In der folgenden Abbildung wird diese Vorgehensweise veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="ad51a-204">The next figure shows this approach.</span></span>

![Abbildung 8: Als Indextabellen fungierende Darstellerpartitionen für Filmdaten](./_images/index-table-figure-8.png)


## <a name="related-patterns-and-guidance"></a><span data-ttu-id="ad51a-206">Zugehörige Muster und Anleitungen</span><span class="sxs-lookup"><span data-stu-id="ad51a-206">Related patterns and guidance</span></span>

<span data-ttu-id="ad51a-207">Die folgenden Muster und Anweisungen können ebenfalls für die Implementierung dieses Musters relevant sein:</span><span class="sxs-lookup"><span data-stu-id="ad51a-207">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="ad51a-208">[Data Consistency Primer (Grundlagen der Datenkonsistenz)](https://msdn.microsoft.com/library/dn589800.aspx):</span><span class="sxs-lookup"><span data-stu-id="ad51a-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="ad51a-209">Eine Indextabelle muss bei Änderungen an Daten, die sie indiziert, aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-209">An index table must be maintained as the data that it indexes changes.</span></span> <span data-ttu-id="ad51a-210">In der Cloud ist es eventuell nicht möglich oder angebracht, Vorgänge durchzuführen, die im Rahmen derselben Transaktion für die Datenänderung einen Index aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="ad51a-210">In the cloud, it might not be possible or appropriate to perform operations that update an index as part of the same transaction that modifies the data.</span></span> <span data-ttu-id="ad51a-211">In diesem Fall ist eine letztlich konsistente Vorgehensweise angebrachter.</span><span class="sxs-lookup"><span data-stu-id="ad51a-211">In that case, an eventually consistent approach is more suitable.</span></span> <span data-ttu-id="ad51a-212">Dieser Artikel enthält Informationen über die mit letztlicher Konsistenz verbundenen Probleme.</span><span class="sxs-lookup"><span data-stu-id="ad51a-212">Provides information on the issues surrounding eventual consistency.</span></span>
- <span data-ttu-id="ad51a-213">[Muster „Sharding“](https://msdn.microsoft.com/library/dn589797.aspx):</span><span class="sxs-lookup"><span data-stu-id="ad51a-213">[Sharding pattern](https://msdn.microsoft.com/library/dn589797.aspx).</span></span> <span data-ttu-id="ad51a-214">Das Muster „Indextabelle“ wird häufig in Verbindung mit Daten, die durch Shards partitioniert werden, verwendet.</span><span class="sxs-lookup"><span data-stu-id="ad51a-214">The Index Table pattern is frequently used in conjunction with data partitioned by using shards.</span></span> <span data-ttu-id="ad51a-215">Das Muster „Sharding“ enthält weitere Informationen darüber, wie ein Datenspeicher in eine Gruppe von Shards aufgeteilt wird.</span><span class="sxs-lookup"><span data-stu-id="ad51a-215">The Sharding pattern provides more information on how to divide a data store into a set of shards.</span></span>
- <span data-ttu-id="ad51a-216">[Muster „Materialisierte Sichten“](materialized-view.md):</span><span class="sxs-lookup"><span data-stu-id="ad51a-216">[Materialized View pattern](materialized-view.md).</span></span> <span data-ttu-id="ad51a-217">Statt Daten zu indizieren, um Abfragen zum Zusammenfassen von Daten zu unterstützen, kann es sinnvoller sein, eine materialisierte Sicht der Daten zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="ad51a-217">Instead of indexing data to support queries that summarize data, it might be more appropriate to create a materialized view of the data.</span></span> <span data-ttu-id="ad51a-218">In diesem Artikel wird beschrieben, wie effizientere Zusammenfassungsabfragen durch die Generierung von vordefinierten Datenansichten unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="ad51a-218">Describes how to support efficient summary queries by generating prepopulated views over data.</span></span>
