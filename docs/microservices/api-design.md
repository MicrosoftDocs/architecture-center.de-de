---
title: API-Design
description: Entwerfen von APIs für Microservices
author: MikeWasson
ms.date: 10/23/2018
ms.openlocfilehash: 80e8e081384a7806880878ae95fbdbc2bb6cc440
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2019
ms.locfileid: "54111040"
---
# <a name="designing-microservices-api-design"></a><span data-ttu-id="b4146-103">Entwerfen von Microservices: API-Design</span><span class="sxs-lookup"><span data-stu-id="b4146-103">Designing microservices: API design</span></span>

<span data-ttu-id="b4146-104">Ein gutes API-Design ist ein wichtiger Aspekt einer Microservices-Architektur, da der gesamte Datenaustausch zwischen Diensten entweder über Nachrichten oder über API-Aufrufe abgewickelt wird.</span><span class="sxs-lookup"><span data-stu-id="b4146-104">Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls.</span></span> <span data-ttu-id="b4146-105">APIs müssen effizient gestaltet sein, um [zu viele E/A-Vorgänge](../antipatterns/chatty-io/index.md) zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="b4146-105">APIs must be efficient to avoid creating [chatty I/O](../antipatterns/chatty-io/index.md).</span></span> <span data-ttu-id="b4146-106">Da Dienste von unabhängigen Teams entworfen werden, müssen APIs über eine klar definierte Semantik und über klar definierte Versionsschemas verfügen, damit andere Dienste nicht durch Updates beeinträchtigt werden.</span><span class="sxs-lookup"><span data-stu-id="b4146-106">Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.</span></span>

![API-Entwurf für Microservices](./images/api-design.png)

<span data-ttu-id="b4146-108">Es ist wichtig, zwischen zwei Arten von APIs zu unterscheiden:</span><span class="sxs-lookup"><span data-stu-id="b4146-108">It's important to distinguish between two types of API:</span></span>

- <span data-ttu-id="b4146-109">Öffentliche APIs, die von Clientanwendungen aufgerufen werden</span><span class="sxs-lookup"><span data-stu-id="b4146-109">Public APIs that client applications call.</span></span>
- <span data-ttu-id="b4146-110">Back-End-APIs, die für die Kommunikation zwischen Diensten verwendet werden</span><span class="sxs-lookup"><span data-stu-id="b4146-110">Backend APIs that are used for interservice communication.</span></span>

<span data-ttu-id="b4146-111">Diese beiden Anwendungsfälle haben unterschiedliche Anforderungen.</span><span class="sxs-lookup"><span data-stu-id="b4146-111">These two use cases have somewhat different requirements.</span></span> <span data-ttu-id="b4146-112">Eine öffentliche API muss mit Clientanwendungen kompatibel sein. Dabei handelt es sich in der Regel um Browseranwendungen oder native mobile Anwendungen.</span><span class="sxs-lookup"><span data-stu-id="b4146-112">A public API must be compatible with client applications, typically browser applications or native mobile applications.</span></span> <span data-ttu-id="b4146-113">In den meisten Fällen verwendet die öffentliche API hierzu REST über HTTP.</span><span class="sxs-lookup"><span data-stu-id="b4146-113">Most of the time, that means the public API will use REST over HTTP.</span></span> <span data-ttu-id="b4146-114">Bei den Back-End-APIs ist hingegen die Netzwerkleistung zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="b4146-114">For the backend APIs, however, you need to take network performance into account.</span></span> <span data-ttu-id="b4146-115">Abhängig von der Granularität Ihrer Dienste kann die Kommunikation zwischen Diensten zu einem hohen Datenverkehrsaufkommen im Netzwerk führen.</span><span class="sxs-lookup"><span data-stu-id="b4146-115">Depending on the granularity of your services, interservice communication can result in a lot of network traffic.</span></span> <span data-ttu-id="b4146-116">Dienste können schnell E/A-gebunden werden.</span><span class="sxs-lookup"><span data-stu-id="b4146-116">Services can quickly become I/O bound.</span></span> <span data-ttu-id="b4146-117">Aspekte wie Serialisierungsgeschwindigkeit und Nutzlastgröße werden dadurch noch wichtiger.</span><span class="sxs-lookup"><span data-stu-id="b4146-117">For that reason, considerations such as serialization speed and payload size become more important.</span></span> <span data-ttu-id="b4146-118">Beliebte Alternativen zur Verwendung von REST über HTTP sind gRPC, Apache Avro und Apache Thrift.</span><span class="sxs-lookup"><span data-stu-id="b4146-118">Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift.</span></span> <span data-ttu-id="b4146-119">Diese Protokolle unterstützen die binäre Serialisierung und sind generell effizienter als HTTP.</span><span class="sxs-lookup"><span data-stu-id="b4146-119">These protocols support binary serialization and are generally more efficient than HTTP.</span></span>

## <a name="considerations"></a><span data-ttu-id="b4146-120">Überlegungen</span><span class="sxs-lookup"><span data-stu-id="b4146-120">Considerations</span></span>

<span data-ttu-id="b4146-121">Im Anschluss finden Sie einige Punkte, die Sie bei der Implementierung einer API berücksichtigen sollten.</span><span class="sxs-lookup"><span data-stu-id="b4146-121">Here are some things to think about when choosing how to implement an API.</span></span>

<span data-ttu-id="b4146-122">**REST oder RPC:**</span><span class="sxs-lookup"><span data-stu-id="b4146-122">**REST vs RPC**.</span></span> <span data-ttu-id="b4146-123">Wägen Sie die Vor- und Nachteile einer REST-basierten Schnittstelle gegen die Vor- und Nachteile einer RPC-basierten Schnittstelle ab.</span><span class="sxs-lookup"><span data-stu-id="b4146-123">Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.</span></span>

- <span data-ttu-id="b4146-124">REST modelliert Ressourcen, wodurch sich Ihr Domänenmodell unter Umständen auf natürliche Weise ausdrücken lässt.</span><span class="sxs-lookup"><span data-stu-id="b4146-124">REST models resources, which can be a natural way express your domain model.</span></span> <span data-ttu-id="b4146-125">REST definiert eine einheitliche Schnittstelle auf der Grundlage von HTTP-Verben, was der Evolvierbarkeit zugute kommt.</span><span class="sxs-lookup"><span data-stu-id="b4146-125">It defines a uniform interface based on HTTP verbs, which encourages evolvability.</span></span> <span data-ttu-id="b4146-126">Die Semantik ist im Hinblick auf Idempotenz, Nebenwirkungen und Antwortcodes klar definiert.</span><span class="sxs-lookup"><span data-stu-id="b4146-126">It has well-defined semantics in terms of idempotency, side effects, and response codes.</span></span> <span data-ttu-id="b4146-127">Außerdem erzwingt REST eine zustandslose Kommunikation, was die Skalierbarkeit verbessert.</span><span class="sxs-lookup"><span data-stu-id="b4146-127">And it enforces stateless communication, which improves scalability.</span></span>

- <span data-ttu-id="b4146-128">Bei RPC stehen eher Vorgänge und Befehle im Mittelpunkt.</span><span class="sxs-lookup"><span data-stu-id="b4146-128">RPC is more oriented around operations or commands.</span></span> <span data-ttu-id="b4146-129">Die Ähnlichkeit zwischen RPC-Schnittstellen und lokalen Methodenaufrufen führt unter Umständen dazu, dass Sie APIs mit übermäßiger Kommunikation entwickeln.</span><span class="sxs-lookup"><span data-stu-id="b4146-129">Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs.</span></span> <span data-ttu-id="b4146-130">Das bedeutet aber nicht, dass die Verwendung von RPC zwingend zu übermäßiger Kommunikation führt.</span><span class="sxs-lookup"><span data-stu-id="b4146-130">However, that doesn't mean RPC must be chatty.</span></span> <span data-ttu-id="b4146-131">Die Schnittstelle muss lediglich sorgfältig entworfen werden.</span><span class="sxs-lookup"><span data-stu-id="b4146-131">It just means you need to use care when designing the interface.</span></span>

<span data-ttu-id="b4146-132">Bei einer RESTful-Schnittstelle fällt die Wahl üblicherweise auf REST über HTTP mit JSON.</span><span class="sxs-lookup"><span data-stu-id="b4146-132">For a RESTful interface, the most common choice is REST over HTTP using JSON.</span></span> <span data-ttu-id="b4146-133">Für eine RPC-basierte Schnittstelle stehen mehrere beliebte Frameworks wie gRPC, Apache Avro und Apache Thrift zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="b4146-133">For an RPC-style interface, there are several popular frameworks, including gRPC, Apache Avro, and Apache Thrift.</span></span>

<span data-ttu-id="b4146-134">**Effizienz:**</span><span class="sxs-lookup"><span data-stu-id="b4146-134">**Efficiency**.</span></span> <span data-ttu-id="b4146-135">Die Effizienz hängt von der Geschwindigkeit, dem Arbeitsspeicher und der Nutzlastgröße ab.</span><span class="sxs-lookup"><span data-stu-id="b4146-135">Consider efficiency in terms of speed, memory, and payload size.</span></span> <span data-ttu-id="b4146-136">Eine gRPC-basierte Schnittstelle ist üblicherweise schneller als REST über HTTP.</span><span class="sxs-lookup"><span data-stu-id="b4146-136">Typically a gRPC-based interface is faster than REST over HTTP.</span></span>

<span data-ttu-id="b4146-137">**Interface Definition Language (IDL):**</span><span class="sxs-lookup"><span data-stu-id="b4146-137">**Interface definition language (IDL)**.</span></span> <span data-ttu-id="b4146-138">Eine IDL dient zum Definieren der Methoden, Parameter und Rückgabewerte einer API.</span><span class="sxs-lookup"><span data-stu-id="b4146-138">An IDL is used to define the methods, parameters, and return values of an API.</span></span> <span data-ttu-id="b4146-139">Mit einer IDL können Sie Clientcode, Serialisierungscode und die API-Dokumentation generieren.</span><span class="sxs-lookup"><span data-stu-id="b4146-139">An IDL can be used to generate client code, serialization code, and API documentation.</span></span> <span data-ttu-id="b4146-140">IDLs können auch von API-Testtools wie Postman genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="b4146-140">IDLs can also be consumed by API testing tools such as Postman.</span></span> <span data-ttu-id="b4146-141">Frameworks wie gRPC, Avro und Thrift definieren ihre eigenen IDL-Spezifikationen.</span><span class="sxs-lookup"><span data-stu-id="b4146-141">Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications.</span></span> <span data-ttu-id="b4146-142">REST über HTTP verfügt zwar nicht über ein IDL-Standardformat, eine gängige Option ist jedoch OpenAPI (ehemals Swagger).</span><span class="sxs-lookup"><span data-stu-id="b4146-142">REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger).</span></span> <span data-ttu-id="b4146-143">Sie können auch eine HTTP-REST-API ohne formale Definitionssprache erstellen, dadurch verlieren Sie aber die Vorteile von Codegenerierung und Tests.</span><span class="sxs-lookup"><span data-stu-id="b4146-143">You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.</span></span>

<span data-ttu-id="b4146-144">**Serialisierung:**</span><span class="sxs-lookup"><span data-stu-id="b4146-144">**Serialization**.</span></span> <span data-ttu-id="b4146-145">Wie werden Objekte bei der Übertragung serialisiert?</span><span class="sxs-lookup"><span data-stu-id="b4146-145">How are objects serialized over the wire?</span></span> <span data-ttu-id="b4146-146">Zur Verfügung stehen textbasierte Formate (hauptsächlich JSON) sowie binäre Formate wie etwa Protokollpuffer.</span><span class="sxs-lookup"><span data-stu-id="b4146-146">Options include text-based formats (primarily JSON) and binary formats such as protocol buffer.</span></span> <span data-ttu-id="b4146-147">Binäre Formate sind im Allgemeinen schneller als textbasierte Formate.</span><span class="sxs-lookup"><span data-stu-id="b4146-147">Binary formats are generally faster than text-based formats.</span></span> <span data-ttu-id="b4146-148">JSON bietet jedoch Vorteile bei der Interoperabilität, da die meisten Sprachen und Frameworks die JSON-Serialisierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="b4146-148">However, JSON has advantages in terms of interoperability, because most languages and frameworks support JSON serialization.</span></span> <span data-ttu-id="b4146-149">Einige Serialisierungsformate benötigen ein festes Schema, und einige erfordern die Kompilierung einer Schemadefinitionsdatei.</span><span class="sxs-lookup"><span data-stu-id="b4146-149">Some serialization formats require a fixed schema, and some require compiling a schema definition file.</span></span> <span data-ttu-id="b4146-150">In diesem Fall müssen Sie diesen Schritt in Ihren Buildprozess integrieren.</span><span class="sxs-lookup"><span data-stu-id="b4146-150">In that case, you'll need to incorporate this step into your build process.</span></span>

<span data-ttu-id="b4146-151">**Framework- und Sprachunterstützung:**</span><span class="sxs-lookup"><span data-stu-id="b4146-151">**Framework and language support**.</span></span> <span data-ttu-id="b4146-152">HTTP wird in nahezu jedem Framework und in fast jeder Sprache unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b4146-152">HTTP is supported in nearly every framework and language.</span></span> <span data-ttu-id="b4146-153">gRPC, Avro und Thrift verfügen jeweils über Bibliotheken für C++, C#, Java und Python.</span><span class="sxs-lookup"><span data-stu-id="b4146-153">gRPC, Avro, and Thrift all have libraries for C++, C#, Java, and Python.</span></span> <span data-ttu-id="b4146-154">Thrift und gRPC unterstützen auch Go.</span><span class="sxs-lookup"><span data-stu-id="b4146-154">Thrift and gRPC also support Go.</span></span>

<span data-ttu-id="b4146-155">**Kompatibilität und Interoperabilität:**</span><span class="sxs-lookup"><span data-stu-id="b4146-155">**Compatibility and interoperability**.</span></span> <span data-ttu-id="b4146-156">Wenn Sie sich für ein Protokoll wie gRPC entscheiden, benötigen Sie unter Umständen eine Protokollübersetzungsebene zwischen der öffentlichen API und dem Back-End.</span><span class="sxs-lookup"><span data-stu-id="b4146-156">If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end.</span></span> <span data-ttu-id="b4146-157">Diese Funktion kann von einem [Gateway](./gateway.md) übernommen werden.</span><span class="sxs-lookup"><span data-stu-id="b4146-157">A [gateway](./gateway.md) can perform that function.</span></span> <span data-ttu-id="b4146-158">Überlegen Sie sich bei Verwendung eines Dienstnetzes, welche Protokolle mit dem Dienstnetz kompatibel sind.</span><span class="sxs-lookup"><span data-stu-id="b4146-158">If you are using a service mesh, consider which protocols are compatible with the service mesh.</span></span> <span data-ttu-id="b4146-159">Linkerd verfügt beispielsweise über integrierte Unterstützung für HTTP, Thrift und gRPC.</span><span class="sxs-lookup"><span data-stu-id="b4146-159">For example, linkerd has built-in support for HTTP, Thrift, and gRPC.</span></span>

<span data-ttu-id="b4146-160">Grundsätzlich empfiehlt es sich, REST über HTTP zu verwenden – es sei denn, Sie benötigen die Leistungsvorteile eines Binärprotokolls.</span><span class="sxs-lookup"><span data-stu-id="b4146-160">Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol.</span></span> <span data-ttu-id="b4146-161">Für REST über HTTP sind keine speziellen Bibliotheken erforderlich.</span><span class="sxs-lookup"><span data-stu-id="b4146-161">REST over HTTP requires no special libraries.</span></span> <span data-ttu-id="b4146-162">Auch die Kopplung hält sich in Grenzen, da Aufrufer für die Kommunikation mit dem Dienst keinen Client-Stub benötigen.</span><span class="sxs-lookup"><span data-stu-id="b4146-162">It creates minimal coupling, because callers don't need a client stub to communicate with the service.</span></span> <span data-ttu-id="b4146-163">Zur Unterstützung von Schemadefinitionen, Tests und der Überwachung von RESTful-HTTP-Endpunkten steht ein umfangreiches Angebot an Tools zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="b4146-163">There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints.</span></span> <span data-ttu-id="b4146-164">Außerdem ist HTTP mit Browserclients kompatibel, sodass keine Protokollübersetzungsebene zwischen Client und Back-End benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="b4146-164">Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.</span></span>

<span data-ttu-id="b4146-165">Wenn Sie sich für REST über HTTP entscheiden, sollten Sie sich allerdings bereits in einer frühen Phase des Entwicklungsprozesses mittels Leistungs- und Auslastungstests vergewissern, dass diese Variante für Ihr Szenario geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="b4146-165">However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.</span></span>

## <a name="restful-api-design"></a><span data-ttu-id="b4146-166">RESTful-API-Design</span><span class="sxs-lookup"><span data-stu-id="b4146-166">RESTful API design</span></span>

<span data-ttu-id="b4146-167">Für das Entwerfen von RESTful-APIs stehen zahlreiche Ressourcen zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="b4146-167">There are many resources for designing RESTful APIs.</span></span> <span data-ttu-id="b4146-168">Eine kleine Auswahl:</span><span class="sxs-lookup"><span data-stu-id="b4146-168">Here are some that you might find helpful:</span></span>

- [<span data-ttu-id="b4146-169">API-Design</span><span class="sxs-lookup"><span data-stu-id="b4146-169">API design</span></span>](../best-practices/api-design.md)

- [<span data-ttu-id="b4146-170">API-Implementierung</span><span class="sxs-lookup"><span data-stu-id="b4146-170">API implementation</span></span>](../best-practices/api-implementation.md)

- <span data-ttu-id="b4146-171">[Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines) (REST-API-Richtlinien von Microsoft)</span><span class="sxs-lookup"><span data-stu-id="b4146-171">[Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines)</span></span>

<span data-ttu-id="b4146-172">Im Anschluss folgen einige Punkte, die Sie berücksichtigen sollten.</span><span class="sxs-lookup"><span data-stu-id="b4146-172">Here are some specific considerations to keep in mind.</span></span>

- <span data-ttu-id="b4146-173">Achten Sie auf APIs, die interne Implementierungsdetails offenlegen oder einfach ein internes Datenbankschema widerspiegeln.</span><span class="sxs-lookup"><span data-stu-id="b4146-173">Watch out for APIs that leak internal implementation details or simply mirror an internal database schema.</span></span> <span data-ttu-id="b4146-174">Die API sollte die Domäne modellieren.</span><span class="sxs-lookup"><span data-stu-id="b4146-174">The API should model the domain.</span></span> <span data-ttu-id="b4146-175">Sie ist ein Vertrag zwischen Diensten und sollte sich im Idealfall nur ändern, wenn neue Funktionen hinzukommen – nicht, weil Sie Code umgestaltet oder eine Datenbanktabelle normalisiert haben.</span><span class="sxs-lookup"><span data-stu-id="b4146-175">It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.</span></span>

- <span data-ttu-id="b4146-176">Unterschiedliche Arten von Clients (etwa mobile Anwendungen und Desktop-Webbrowser) erfordern unter Umständen unterschiedliche Nutzlastgrößen oder Interaktionsmuster.</span><span class="sxs-lookup"><span data-stu-id="b4146-176">Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns.</span></span> <span data-ttu-id="b4146-177">Erstellen Sie ggf. unter Verwendung des Musters [Back-Ends für Front-Ends](../patterns/backends-for-frontends.md) separate Back-Ends für die einzelnen Clients, die eine optimale Schnittstelle für den jeweiligen Client verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="b4146-177">Consider using the [Backends for Frontends pattern](../patterns/backends-for-frontends.md) to create separate backends for each client, that expose an optimal interface for that client.</span></span>

- <span data-ttu-id="b4146-178">Machen Sie Vorgänge mit Nebenwirkungen ggf. idempotent, und implementieren Sie sie als PUT-Methoden.</span><span class="sxs-lookup"><span data-stu-id="b4146-178">For operations with side effects, consider making them idempotent and implementing them as PUT methods.</span></span> <span data-ttu-id="b4146-179">Das ermöglicht sichere Wiederholungen und kann die Resilienz verbessern.</span><span class="sxs-lookup"><span data-stu-id="b4146-179">That will enable safe retries and can improve resiliency.</span></span> <span data-ttu-id="b4146-180">Dieser Aspekt wird in den Themen [Erfassung und Workflow](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) und [Kommunikation zwischen Diensten](./interservice-communication.md) ausführlicher behandelt.</span><span class="sxs-lookup"><span data-stu-id="b4146-180">The chapters [Ingestion and workflow](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) and [Interservice communication](./interservice-communication.md) discuss this issue in more detail.</span></span>

- <span data-ttu-id="b4146-181">HTTP-Methoden können über asynchrone Semantik verfügen, sodass die Methode zwar umgehend eine Antwort zurückgibt, der Dienst den Vorgang aber asynchron ausführt.</span><span class="sxs-lookup"><span data-stu-id="b4146-181">HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously.</span></span> <span data-ttu-id="b4146-182">In diesem Fall sollte die Methode den Antwortcode [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) zurückgeben. Dieser Code gibt an, dass die Anforderung zur Verarbeitung akzeptiert wurde, die Verarbeitung aber noch nicht abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="b4146-182">In that case, the method should return an [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) response code, which indicates the request was accepted for processing, but the processing is not yet completed.</span></span>

## <a name="mapping-rest-to-ddd-patterns"></a><span data-ttu-id="b4146-183">Zuordnen von REST zu DDD-Mustern</span><span class="sxs-lookup"><span data-stu-id="b4146-183">Mapping REST to DDD patterns</span></span>

<span data-ttu-id="b4146-184">Muster wie Entität, Aggregat und Wertobjekt dienen dazu, bestimmte Einschränkungen auf die Objekte in Ihrem Domänenmodell anzuwenden.</span><span class="sxs-lookup"><span data-stu-id="b4146-184">Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model.</span></span> <span data-ttu-id="b4146-185">In vielen DDD-Diskussionen werden die Muster mithilfe objektorientierter Sprachkonzepte wie Konstruktoren oder Getter-/Setter-Elementen für Eigenschaften modelliert.</span><span class="sxs-lookup"><span data-stu-id="b4146-185">In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters.</span></span> <span data-ttu-id="b4146-186">Ein Beispiel: *Wertobjekte* müssen unveränderlich sein.</span><span class="sxs-lookup"><span data-stu-id="b4146-186">For example, *value objects* are supposed to be immutable.</span></span> <span data-ttu-id="b4146-187">In einer objektorientierten Programmiersprache wird dies erzwungen, indem die Werte im Konstruktor zugewiesen und die Eigenschaften schreibgeschützt werden:</span><span class="sxs-lookup"><span data-stu-id="b4146-187">In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:</span></span>

```ts
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```

<span data-ttu-id="b4146-188">Solche Programmiermethoden sind besonders bei der Erstellung einer herkömmlichen monolithischen Anwendung wichtig.</span><span class="sxs-lookup"><span data-stu-id="b4146-188">These sorts of coding practices are particularly important when building a traditional monolithic application.</span></span> <span data-ttu-id="b4146-189">Bei einer umfangreichen Codebasis wird das Objekt `Location` unter Umständen von vielen Subsystemen verwendet. Daher ist es für das Objekt wichtig, das korrekte Verhalten zu erzwingen.</span><span class="sxs-lookup"><span data-stu-id="b4146-189">With a large code base, many subsystems might use the `Location` object, so it's important for the object to enforce correct behavior.</span></span>

<span data-ttu-id="b4146-190">Ein weiteres Beispiel ist das Repository-Muster, das sicherstellt, dass andere Teile der Anwendung nicht direkt aus dem Datenspeicher lesen oder direkt in den Datenspeicher schreiben:</span><span class="sxs-lookup"><span data-stu-id="b4146-190">Another example is the Repository pattern, which ensures that other parts of the application do not make direct reads or writes to the data store:</span></span>

<span data-ttu-id="b4146-191">![Diagramm eines Drohnenrepositorys](./images/repository.png)</span><span class="sxs-lookup"><span data-stu-id="b4146-191">!Diagram of a Drone Repository[](./images/repository.png)</span></span>

<span data-ttu-id="b4146-192">In einer Microservices-Architektur verwenden Dienste jedoch nicht die gleiche Codebasis und teilen sich keine Datenspeicher.</span><span class="sxs-lookup"><span data-stu-id="b4146-192">In a microservices architecture, however, services don't share the same code base and don't share data stores.</span></span> <span data-ttu-id="b4146-193">Stattdessen kommunizieren sie über APIs.</span><span class="sxs-lookup"><span data-stu-id="b4146-193">Instead, they communicate through APIs.</span></span> <span data-ttu-id="b4146-194">Ein Beispiel: Angenommen, der Dienst „Scheduler“ (Planung) fordert vom Dienst „Drone“ (Drohne) Informationen zu einer Drohne an.</span><span class="sxs-lookup"><span data-stu-id="b4146-194">Consider the case where the Scheduler service requests information about a drone from the Drone service.</span></span> <span data-ttu-id="b4146-195">Der Drohnendienst verfügt über ein durch Code ausgedrücktes Modell einer Drohne.</span><span class="sxs-lookup"><span data-stu-id="b4146-195">The Drone service has its internal model of a drone, expressed through code.</span></span> <span data-ttu-id="b4146-196">Dieses steht dem Planungsdienst jedoch nicht zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="b4146-196">But the Scheduler doesn't see that.</span></span> <span data-ttu-id="b4146-197">Stattdessen wird an ihn eine *Darstellung* der Drohnenentität &mdash;zurückgegeben – beispielsweise als JSON-Objekt in einer HTTP-Antwort.</span><span class="sxs-lookup"><span data-stu-id="b4146-197">Instead, it gets back a *representation* of the drone entity &mdash; perhaps a JSON object in an HTTP response.</span></span>

![Diagramm des Drohnendiensts](./images/ddd-rest.png)

<span data-ttu-id="b4146-199">Der Planungsdienst kann die internen Modelle des Drohnendiensts nicht ändern oder Code in den Datenspeicher des Drohnendiensts schreiben.</span><span class="sxs-lookup"><span data-stu-id="b4146-199">The Scheduler service can't modify the Drone service's internal models, or write to the Drone service's data store.</span></span> <span data-ttu-id="b4146-200">Das bedeutet, der Code, der den Drohnendienst implementiert, hat im Vergleich zu einer herkömmlichen monolithischen Anwendung eine kompaktere verfügbare Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="b4146-200">That means the code that implements the Drone service has a smaller exposed surface area, compared with code in a traditional monolith.</span></span> <span data-ttu-id="b4146-201">Wenn der Drohnendienst eine Klasse vom Typ „Location“ (Position) &mdash;definiert, ist der Geltungsbereich dieser Klasse eingeschränkt, sodass die Klasse von keinem anderen Dienst direkt genutzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="b4146-201">If the Drone service defines a Location class, the scope of that class is limited &mdash; no other service will directly consume the class.</span></span>

<span data-ttu-id="b4146-202">Aus diesen Gründen gehen wir in diesem Leitfaden nicht weiter auf Programmiermethoden ein, die sich auf die taktischen DDD-Muster beziehen.</span><span class="sxs-lookup"><span data-stu-id="b4146-202">For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns.</span></span> <span data-ttu-id="b4146-203">Es stellt sich jedoch heraus, dass Sie viele der DDD-Muster auch über REST-APIs modellieren können.</span><span class="sxs-lookup"><span data-stu-id="b4146-203">But it turns out that you can also model many of the DDD patterns through REST APIs.</span></span>

<span data-ttu-id="b4146-204">Beispiel: </span><span class="sxs-lookup"><span data-stu-id="b4146-204">For example:</span></span>

- <span data-ttu-id="b4146-205">Aggregate lassen sich auf natürliche Weise *Ressourcen* in REST zuordnen.</span><span class="sxs-lookup"><span data-stu-id="b4146-205">Aggregates map naturally to *resources* in REST.</span></span> <span data-ttu-id="b4146-206">So wird beispielsweise das Aggregat „Delivery“ (Lieferung) durch die Delivery-API als Ressource verfügbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="b4146-206">For example, the Delivery aggregate would be exposed as a resource by the Delivery API.</span></span>

- <span data-ttu-id="b4146-207">Aggregate sind Konsistenzgrenzen.</span><span class="sxs-lookup"><span data-stu-id="b4146-207">Aggregates are consistency boundaries.</span></span> <span data-ttu-id="b4146-208">Aggregatvorgänge dürfen niemals dazu führen, dass sich ein Aggregat in einem inkonsistenten Zustand befindet.</span><span class="sxs-lookup"><span data-stu-id="b4146-208">Operations on aggregates should never leave an aggregate in an inconsistent state.</span></span> <span data-ttu-id="b4146-209">Daher sollten Sie keine APIs erstellen, über die ein Client den internen Zustand eines Aggregats ändern kann.</span><span class="sxs-lookup"><span data-stu-id="b4146-209">Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.</span></span> <span data-ttu-id="b4146-210">Verwenden Sie stattdessen undifferenzierte APIs, die Aggregate als Ressourcen verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="b4146-210">Instead, favor coarse-grained APIs that expose aggregates as resources.</span></span>

- <span data-ttu-id="b4146-211">Entitäten verfügen über eindeutige Identitäten.</span><span class="sxs-lookup"><span data-stu-id="b4146-211">Entities have unique identities.</span></span> <span data-ttu-id="b4146-212">In REST besitzen Ressourcen eindeutige Bezeichner in Form von URLs.</span><span class="sxs-lookup"><span data-stu-id="b4146-212">In REST, resources have unique identifiers in the form of URLs.</span></span> <span data-ttu-id="b4146-213">Erstellen Sie Ressourcen-URLs, die der Domänenidentität einer Entität entsprechen.</span><span class="sxs-lookup"><span data-stu-id="b4146-213">Create resource URLs that correspond to an entity's domain identity.</span></span> <span data-ttu-id="b4146-214">Die Zuordnung von URLs zu Domänenidentitäten muss für den Client nicht transparent sein.</span><span class="sxs-lookup"><span data-stu-id="b4146-214">The mapping from URL to domain identity may be opaque to client.</span></span>

- <span data-ttu-id="b4146-215">Untergeordnete Entitäten eines Aggregats sind per Navigation über die Stammentität erreichbar.</span><span class="sxs-lookup"><span data-stu-id="b4146-215">Child entities of an aggregate can be reached by navigating from the root entity.</span></span> <span data-ttu-id="b4146-216">Wenn Sie sich an die [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)-Prinzipien halten, sind untergeordnete Entitäten über Links in der Darstellung der übergeordneten Entität erreichbar.</span><span class="sxs-lookup"><span data-stu-id="b4146-216">If you follow [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) principles, child entities can be reached via links in the representation of the parent entity.</span></span>

- <span data-ttu-id="b4146-217">Da Wertobjekte unveränderlich sind, wird zur Aktualisierung das gesamte Wertobjekt ersetzt.</span><span class="sxs-lookup"><span data-stu-id="b4146-217">Because value objects are immutable, updates are performed by replacing the entire value object.</span></span> <span data-ttu-id="b4146-218">In REST werden Aktualisierungen über PUT oder PATCH-Anforderungen implementiert.</span><span class="sxs-lookup"><span data-stu-id="b4146-218">In REST, implement updates through PUT or PATCH requests.</span></span>

- <span data-ttu-id="b4146-219">Ein Repository ermöglicht es Clients, Objekte in einer Sammlung abzufragen sowie Objekte zu einer Sammlung hinzuzufügen oder daraus zu entfernen, wobei die Details des zugrunde liegenden Datenspeichers abstrahiert werden.</span><span class="sxs-lookup"><span data-stu-id="b4146-219">A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store.</span></span> <span data-ttu-id="b4146-220">In REST kann eine Sammlung eine eigenständige Ressource sein – mit Methoden zum Abfragen der Sammlung oder zum Hinzufügen neuer Entitäten.</span><span class="sxs-lookup"><span data-stu-id="b4146-220">In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.</span></span>

<span data-ttu-id="b4146-221">Berücksichtigen Sie beim Entwerfen Ihrer APIs, dass diese nicht nur die Daten innerhalb des Modells, sondern das Domänenmodell an sich sowie die geschäftlichen Abläufe und die Einschränkungen für die Daten ausdrücken.</span><span class="sxs-lookup"><span data-stu-id="b4146-221">When you design your APIs, think about how they express the domain model, not just the data inside the model, but also the business operations and the constraints on the data.</span></span>

| <span data-ttu-id="b4146-222">DDD-Konzept</span><span class="sxs-lookup"><span data-stu-id="b4146-222">DDD concept</span></span> | <span data-ttu-id="b4146-223">REST-Entsprechung</span><span class="sxs-lookup"><span data-stu-id="b4146-223">REST equivalent</span></span> | <span data-ttu-id="b4146-224">Beispiel</span><span class="sxs-lookup"><span data-stu-id="b4146-224">Example</span></span> |
|-------------|-----------------|---------|
| <span data-ttu-id="b4146-225">Aggregat</span><span class="sxs-lookup"><span data-stu-id="b4146-225">Aggregate</span></span> | <span data-ttu-id="b4146-226">Ressource</span><span class="sxs-lookup"><span data-stu-id="b4146-226">Resource</span></span> | `{ "1":1234, "status":"pending"... }` |
| <span data-ttu-id="b4146-227">Identity</span><span class="sxs-lookup"><span data-stu-id="b4146-227">Identity</span></span> | <span data-ttu-id="b4146-228">URL</span><span class="sxs-lookup"><span data-stu-id="b4146-228">URL</span></span> | `https://delivery-service/deliveries/1` |
| <span data-ttu-id="b4146-229">Untergeordnete Entitäten</span><span class="sxs-lookup"><span data-stu-id="b4146-229">Child entities</span></span> | <span data-ttu-id="b4146-230">Links</span><span class="sxs-lookup"><span data-stu-id="b4146-230">Links</span></span> | `{ "href": "/deliveries/1/confirmation" }` |
| <span data-ttu-id="b4146-231">Aktualisierung von Wertobjekten</span><span class="sxs-lookup"><span data-stu-id="b4146-231">Update value objects</span></span> | <span data-ttu-id="b4146-232">PUT oder PATCH</span><span class="sxs-lookup"><span data-stu-id="b4146-232">PUT or PATCH</span></span> | `PUT https://delivery-service/deliveries/1/dropoff` |
| <span data-ttu-id="b4146-233">Repository</span><span class="sxs-lookup"><span data-stu-id="b4146-233">Repository</span></span> | <span data-ttu-id="b4146-234">Sammlung</span><span class="sxs-lookup"><span data-stu-id="b4146-234">Collection</span></span> | `https://delivery-service/deliveries?status=pending` |

## <a name="api-versioning"></a><span data-ttu-id="b4146-235">API-Versionsverwaltung</span><span class="sxs-lookup"><span data-stu-id="b4146-235">API versioning</span></span>

<span data-ttu-id="b4146-236">Eine API ist ein Vertrag zwischen einem Dienst und den Clients oder Consumern dieses Diensts.</span><span class="sxs-lookup"><span data-stu-id="b4146-236">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="b4146-237">Wenn sich eine API ändert, besteht die Gefahr, dass Clients, die von der API abhängig sind, nicht mehr funktionieren. Dabei spielt es keine Rolle, ob es sich bei diesen Clients um externe Clients oder um andere Microservices handelt.</span><span class="sxs-lookup"><span data-stu-id="b4146-237">If an API changes, there is a risk of breaking clients that depend on the API, whether those are external clients or other microservices.</span></span> <span data-ttu-id="b4146-238">Es empfiehlt sich daher, möglichst selten API-Änderungen vorzunehmen.</span><span class="sxs-lookup"><span data-stu-id="b4146-238">Therefore, it's a good idea to minimize the number of API changes that you make.</span></span> <span data-ttu-id="b4146-239">Änderungen an der zugrunde liegenden Implementierung erfordern häufig keine Änderung der API.</span><span class="sxs-lookup"><span data-stu-id="b4146-239">Often, changes in the underlying implementation don't require any changes to the API.</span></span> <span data-ttu-id="b4146-240">Irgendwann möchten Sie aber vermutlich neue Features oder Funktionen hinzufügen, die die Änderung einer vorhandenen API erfordern.</span><span class="sxs-lookup"><span data-stu-id="b4146-240">Realistically, however, at some point you will want to add new features or new capabilities that require changing an existing API.</span></span>

<span data-ttu-id="b4146-241">API-Änderungen sollten nach Möglichkeit abwärtskompatibel sein.</span><span class="sxs-lookup"><span data-stu-id="b4146-241">Whenever possible, make API changes backward compatible.</span></span> <span data-ttu-id="b4146-242">Vermeiden Sie es beispielsweise, ein Feld aus einem Modell zu entfernen, da dies dazu führen kann, dass Clients, die dieses Feld erwarten, nicht mehr funktionieren.</span><span class="sxs-lookup"><span data-stu-id="b4146-242">For example, avoid removing a field from a model, because that can break clients that expect the field to be there.</span></span> <span data-ttu-id="b4146-243">Das Hinzufügen eines Felds hat keine negativen Auswirkungen auf die Kompatibilität, da Clients Felder, die sie in einer Antwort nicht verstehen, grundsätzlich ignorieren sollten.</span><span class="sxs-lookup"><span data-stu-id="b4146-243">Adding a field does not break compatibility, because clients should ignore any fields they don't understand in a response.</span></span> <span data-ttu-id="b4146-244">Der Dienst muss jedoch den Fall behandeln, dass das neue Feld von einem älteren Client in einer Anforderung übergangen wird.</span><span class="sxs-lookup"><span data-stu-id="b4146-244">However, the service must handle the case where an older client omits the new field in a request.</span></span>

<span data-ttu-id="b4146-245">Unterstützen Sie die Versionsverwaltung in Ihrem API-Vertrag.</span><span class="sxs-lookup"><span data-stu-id="b4146-245">Support versioning in your API contract.</span></span> <span data-ttu-id="b4146-246">Wenn Sie eine grundlegende API-Änderung einführen, verbinden Sie dies mit der Einführung einer neuen API-Version.</span><span class="sxs-lookup"><span data-stu-id="b4146-246">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="b4146-247">Unterstützen Sie die vorherige Version weiter, und lassen Sie Clients die Wahl, welche Version sie aufrufen möchten.</span><span class="sxs-lookup"><span data-stu-id="b4146-247">Continue to support the previous version, and let clients select which version to call.</span></span> <span data-ttu-id="b4146-248">Dies kann auf unterschiedliche Weise erreicht werden.</span><span class="sxs-lookup"><span data-stu-id="b4146-248">There are a couple of ways to do this.</span></span> <span data-ttu-id="b4146-249">Sie können beispielsweise einfach beide Versionen im gleichen Dienst verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="b4146-249">One is simply to expose both versions in the same service.</span></span> <span data-ttu-id="b4146-250">Eine andere Möglichkeit besteht darin, zwei Versionen des Diensts parallel auszuführen und Anforderungen auf der Grundlage von HTTP-Routingregeln an eine der Versionen weiterzuleiten.</span><span class="sxs-lookup"><span data-stu-id="b4146-250">Another option is to run two versions of the service side-by-side, and route requests to one or the other version, based on HTTP routing rules.</span></span>

![Versionsverwaltung](./images/versioning1.svg)

<span data-ttu-id="b4146-252">Die Unterstützung mehrerer Versionen ist mit zusätzlicher Entwicklungszeit, zusätzlichen Tests und zusätzlichem Aufwand beim Betrieb verbunden.</span><span class="sxs-lookup"><span data-stu-id="b4146-252">There's a cost to supporting multiple versions, in terms of developer time, testing, and operational overhead.</span></span> <span data-ttu-id="b4146-253">Es empfiehlt sich daher, alte Versionen schnellstmöglich auszumustern.</span><span class="sxs-lookup"><span data-stu-id="b4146-253">Therefore, it's good to deprecate old versions as quickly as possible.</span></span> <span data-ttu-id="b4146-254">Bei internen APIs kann das für die API zuständige Team mit anderen Teams zusammenarbeiten, um sie bei der Migration zu der neuen Version zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="b4146-254">For internal APIs, the team that owns the API can work with other teams to help them migrate to the new version.</span></span> <span data-ttu-id="b4146-255">Hier ist ein teamübergreifender Governance-Prozess hilfreich.</span><span class="sxs-lookup"><span data-stu-id="b4146-255">This is when having a cross-team governance process is useful.</span></span> <span data-ttu-id="b4146-256">Bei externen (öffentlichen) APIs kann die Ausmusterung einer API-Version schwieriger sein – insbesondere, wenn die API von Drittanbietern oder von nativen Clientanwendungen genutzt wird.</span><span class="sxs-lookup"><span data-stu-id="b4146-256">For external (public) APIs, it can be harder to deprecate an API version, especially if the API is consumed by third parties or by native client applications.</span></span>

<span data-ttu-id="b4146-257">Wenn sich eine Dienstimplementierung ändert, ist es hilfreich, die Änderung mit einer Version zu kennzeichnen.</span><span class="sxs-lookup"><span data-stu-id="b4146-257">When a service implementation changes, it's useful to tag the change with a version.</span></span> <span data-ttu-id="b4146-258">Die Version liefert wichtige Informationen für die Fehlerbehandlung.</span><span class="sxs-lookup"><span data-stu-id="b4146-258">The version provides important information when troubleshooting errors.</span></span> <span data-ttu-id="b4146-259">Bei der Ursachenanalyse kann es überaus hilfreich sein, genau zu wissen, welche Dienstversion aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="b4146-259">It can be very helpful for root cause analysis to know exactly which version of the service was called.</span></span> <span data-ttu-id="b4146-260">Erwägen Sie bei Dienstversionen die Anwendung von [Semantic Versioning](https://semver.org/) (semantische Versionierung).</span><span class="sxs-lookup"><span data-stu-id="b4146-260">Consider using [semantic versioning](https://semver.org/) for service versions.</span></span> <span data-ttu-id="b4146-261">Die semantische Versionierung verwendet das Format *HAUPTVERSION.NEBENVERSION.PATCH*.</span><span class="sxs-lookup"><span data-stu-id="b4146-261">Semantic versioning uses a *MAJOR.MINOR.PATCH* format.</span></span> <span data-ttu-id="b4146-262">Clients sollten eine API jedoch nur anhand der Hauptversionsnummer auswählen – oder ggf. anhand der Nebenversion, sofern zwischen Nebenversionen wesentliche Änderungen vorgenommen wurden, die allerdings nicht zu einer Beeinträchtigung führen dürfen.</span><span class="sxs-lookup"><span data-stu-id="b4146-262">However, clients should only select an API by the major version number, or possibly the minor version if there are significant (but non-breaking) changes between minor versions.</span></span> <span data-ttu-id="b4146-263">Anders ausgedrückt: Für Clients ist es sinnvoll, zwischen Version 1 und Version 2 einer API zu wählen. Die Wahl der Version 2.1.3 ist hingegen nicht sinnvoll.</span><span class="sxs-lookup"><span data-stu-id="b4146-263">In other words, it's reasonable for clients to select between version 1 and version 2 of an API, but not to select version 2.1.3.</span></span> <span data-ttu-id="b4146-264">Bei einer solchen Granularität besteht die Gefahr, dass Sie mehr und mehr Versionen unterstützen müssen.</span><span class="sxs-lookup"><span data-stu-id="b4146-264">If you allow that level of granularity, you risk having to support a proliferation of versions.</span></span>

<span data-ttu-id="b4146-265">Weitere Informationen zur API-Versionsverwaltung finden Sie unter [Versionsverwaltung einer RESTful-Web-API](../best-practices/api-design.md#versioning-a-restful-web-api).</span><span class="sxs-lookup"><span data-stu-id="b4146-265">For further discussion of API versioning, see [Versioning a RESTful web API](../best-practices/api-design.md#versioning-a-restful-web-api).</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="b4146-266">Erfassung und Workflow</span><span class="sxs-lookup"><span data-stu-id="b4146-266">Ingestion and workflow</span></span>](./ingestion-workflow.md)