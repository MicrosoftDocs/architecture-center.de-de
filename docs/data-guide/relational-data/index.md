---
title: Relationale Daten
description: ''
author: zoinerTejada
ms.date: 02/12/2018
ms.openlocfilehash: 499e7c632bd6bfee31c0625f4d647825107ea2bb
ms.sourcegitcommit: 1f4cdb08fe73b1956e164ad692f792f9f635b409
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/08/2019
ms.locfileid: "54111817"
---
# <a name="traditional-relational-database-solutions"></a><span data-ttu-id="e4f6e-102">Herkömmliche relationale Datenbanklösungen</span><span class="sxs-lookup"><span data-stu-id="e4f6e-102">Traditional relational database solutions</span></span>

<span data-ttu-id="e4f6e-103">Bei relationalen Daten handelt es sich um Daten, die mit dem relationalen Modell modelliert werden.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-103">Relational data is data modeled using the relational model.</span></span> <span data-ttu-id="e4f6e-104">Bei diesem Modell werden Daten als Tupel ausgedrückt.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-104">In this model, data is expressed as tuples.</span></span> <span data-ttu-id="e4f6e-105">Ein *Tupel* ist ein Satz mit Attribut-Wert-Paaren.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-105">A *tuple* is a set of attribute/value pairs.</span></span> <span data-ttu-id="e4f6e-106">Beispiel für ein Tupel: (itemid = 5, orderid = 1, item = "Chair", amount = 200.00).</span><span class="sxs-lookup"><span data-stu-id="e4f6e-106">For example, a tuple might be (itemid = 5, orderid = 1, item = "Chair", amount = 200.00).</span></span> <span data-ttu-id="e4f6e-107">Eine Tupelmenge, bei der die Tupel die Attribute gemeinsam nutzen, wird als *Relation* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-107">A set of tuples that all share the same attributes is called a *relation*.</span></span>

<span data-ttu-id="e4f6e-108">Relationen werden natürlich als Tabellen dargestellt, wobei jedes Tupel in der Tabelle als Zeile verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-108">Relations are naturally represented as tables, where each tuple is exposed as a row in the table.</span></span> <span data-ttu-id="e4f6e-109">Für Zeilen gilt – im Gegensatz zu Tupeln – aber eine explizite Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-109">However, rows have an explicit ordering, unlike tuples.</span></span> <span data-ttu-id="e4f6e-110">Im Datenbankschema sind die Spalten (Überschriften) jeder Tabelle definiert.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-110">The database schema defines the columns (headings) of each table.</span></span> <span data-ttu-id="e4f6e-111">Jede Spalte wird übergreifend für alle Zeilen der Tabelle mit einem Namen und einem Datentyp für alle Werte definiert, die in dieser Spalte gespeichert sind.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-111">Each column is defined with a name and a data type for all values stored in that column across all rows in the table.</span></span>

![Beispiel mit Daten bei Nutzung einer relationalen Datenbank](../images/example-relational.png)

<span data-ttu-id="e4f6e-113">Ein Datenspeicher, in dem Daten nach dem relationalen Modell organisiert sind, wird als relationale Datenbank bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-113">A data store that organizes data using the relational model is referred to as a relational database.</span></span> <span data-ttu-id="e4f6e-114">Die Zeilen einer Tabelle werden mit Primärschlüsseln eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-114">Primary keys uniquely identify rows within a table.</span></span> <span data-ttu-id="e4f6e-115">Fremdschlüsselfelder werden in einer Tabelle verwendet, um auf eine Zeile in einer anderen Tabelle zu verweisen, indem auf den Primärschlüssel der anderen Tabelle verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-115">Foreign key fields are used in one table to refer to a row in another table by referencing the primary key of the other table.</span></span> <span data-ttu-id="e4f6e-116">Fremdschlüssel werden verwendet, um die referentielle Integrität zu wahren und sicherzustellen, dass die referenzierten Zeilen nicht geändert oder gelöscht werden, während die verweisende Zeile davon abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-116">Foreign keys are used to maintain referential integrity, ensuring that the referenced rows are not altered or deleted while the referencing row depends on them.</span></span>

![Beispiel mit Daten bei Nutzung einer relationalen Datenbank](../images/example-relational2.png)

<span data-ttu-id="e4f6e-118">Relationale Datenbanken unterstützen verschiedene Arten von Einschränkungen, die zur Sicherstellung der Datenintegrität beitragen:</span><span class="sxs-lookup"><span data-stu-id="e4f6e-118">Relational databases support various types of constraints that help to ensure data integrity:</span></span>

- <span data-ttu-id="e4f6e-119">Mit eindeutigen Einschränkungen wird erreicht, dass alle Werte einer Spalte eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-119">Unique constraints ensure that all values in a column are unique.</span></span>

- <span data-ttu-id="e4f6e-120">Mit Fremdschlüsseleinschränkungen wird eine Verknüpfung zwischen den Daten in zwei Tabellen erzwungen.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-120">Foreign key constraints enforce a link between the data in two tables.</span></span> <span data-ttu-id="e4f6e-121">Ein Fremdschlüssel verweist auf den Primärschlüssel oder einen anderen eindeutigen Schlüssel aus der anderen Tabelle.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-121">A foreign key references the primary key or another unique key from another table.</span></span> <span data-ttu-id="e4f6e-122">Eine Fremdschlüsseleinschränkung erzwingt die referentielle Integrität, und Änderungen, die zu ungültigen Fremdschlüsselwerten führen, werden nicht zugelassen.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-122">A foreign key constraint enforces referential integrity, disallowing changes that cause invalid foreign key values.</span></span>

- <span data-ttu-id="e4f6e-123">CHECK-Einschränkungen, die auch als Integritätseinschränkungen bezeichnet werden, sorgen für eine Begrenzung der Werte, die in einer Spalte oder bezogen auf Werte in anderen Spalten derselben Zeile gespeichert werden können.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-123">Check constraints, also known as entity integrity constraints, limit the values that can be stored within a single column, or in relationship to values in other columns of the same row.</span></span>

<span data-ttu-id="e4f6e-124">Für die meisten relationalen Datenbanken wird die Structured Query Language (SQL) verwendet, die einen deklarativen Ansatz für das Durchführen von Abfragen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-124">Most relational databases use the Structured Query Language (SQL) language that enables a declarative approach to querying.</span></span> <span data-ttu-id="e4f6e-125">In der Abfrage wird das gewünschte Ergebnis beschrieben, aber nicht die Schritte zum Ausführen der Abfrage.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-125">The query describes the desired result, but not the steps to execute the query.</span></span> <span data-ttu-id="e4f6e-126">Das Modul wählt dann den besten Weg zum Durchführen der Abfrage.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-126">The engine then decides the best way to execute the query.</span></span> <span data-ttu-id="e4f6e-127">Dies unterscheidet sich von einem prozeduralen Ansatz, bei dem die Verarbeitungsschritte über das Abfrageprogramm explizit angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-127">This differs from a procedural approach, where the query program specifies the processing steps explicitly.</span></span> <span data-ttu-id="e4f6e-128">In relationalen Datenbanken können Routinen mit ausführbarem Code aber in Form von gespeicherten Prozeduren und Funktionen gespeichert werden, sodass eine Mischung von deklarativen und prozeduralen Ansätzen möglich ist.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-128">However, relational databases can store executable code routines in the form of stored procedures and functions, which enables a mixture of declarative and procedural approaches.</span></span>

<span data-ttu-id="e4f6e-129">Zur Verbesserung der Abfrageleistung werden in relationalen Datenbanken *Indizes* verwendet.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-129">To improve query performance, relational databases use *indexes*.</span></span> <span data-ttu-id="e4f6e-130">Mit primären Indizes, die vom Primärschlüssel genutzt werden, wird die Reihenfolge der Daten auf dem Datenträger definiert.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-130">Primary indexes, which are used by the primary key, define the order of the data as it sits on disk.</span></span> <span data-ttu-id="e4f6e-131">Bei sekundären Indizes ist eine andere Kombination von Feldern möglich, sodass die gewünschten Zeilen effizient abgefragt werden können, ohne dass die gesamten Daten auf dem Datenträger neu sortiert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-131">Secondary indexes provide an alternative combination of fields, so the desired rows can be queried efficiently, without having to re-sort the entire data on disk.</span></span>

<span data-ttu-id="e4f6e-132">Da mit relationalen Datenbanken die referentielle Integrität erzwungen wird, kann das Skalieren einer relationalen Datenbank schwierig sein.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-132">Because relational databases enforce referential integrity, scaling a relational database can become challenging.</span></span> <span data-ttu-id="e4f6e-133">Dies liegt daran, dass von jedem Abfrage- oder Einfügevorgang eine große Zahl von Tabellen betroffen sein kann.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-133">That's because any query or insert operation might touch any number of tables.</span></span> <span data-ttu-id="e4f6e-134">Sie können eine relationale Datenbank horizontal hochskalieren, indem Sie für die Daten das *Sharding* durchführen. Hierfür ist aber ein sorgfältiger Schemaentwurf erforderlich.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-134">You can scale out a relational database by *sharding* the data, but this requires careful design of the schema.</span></span> <span data-ttu-id="e4f6e-135">Weitere Informationen finden Sie unter [Sharding Pattern](../../patterns/sharding.md).</span><span class="sxs-lookup"><span data-stu-id="e4f6e-135">For more information, see the [Sharding pattern](../../patterns/sharding.md).</span></span>

<span data-ttu-id="e4f6e-136">Wenn Daten nicht relational sind oder über Anforderungen verfügen, die für eine relationale Datenbank nicht geeignet sind, können Sie einen [nicht relationalen oder NoSQL](../big-data/non-relational-data.md)-Datenspeicher verwenden.</span><span class="sxs-lookup"><span data-stu-id="e4f6e-136">If data is non-relational or has requirements that are not suited to a relational database, consider a [Non-relational or NoSQL](../big-data/non-relational-data.md) data store.</span></span>
