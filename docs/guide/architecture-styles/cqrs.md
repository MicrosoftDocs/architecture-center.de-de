---
title: Architekturstil „CQRS“
description: In diesem Artikel werden die Vorteile, Herausforderungen und bewährten Methoden für CQRS-Architekturen beschrieben.
author: MikeWasson
ms.openlocfilehash: dd3da5886587159f57646ff1bfffa2094725f798
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 11/14/2017
---
# <a name="cqrs-architecture-style"></a><span data-ttu-id="30e0d-103">Architekturstil „CQRS“</span><span class="sxs-lookup"><span data-stu-id="30e0d-103">CQRS architecture style</span></span>

<span data-ttu-id="30e0d-104">CQRS (Command and Query Responsibility Segregation, Befehlsabfrage-Zuständigkeitstrennung) ist ein Architekturstil, bei dem Lesevorgänge von Schreibvorgängen getrennt werden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-104">Command and Query Responsibility Segregation (CQRS) is an architecture style that separates read operations from write operations.</span></span> 

![](./images/cqrs-logical.svg)

<span data-ttu-id="30e0d-105">In herkömmlichen Architekturen wird zum Abfragen und Aktualisieren einer Datenbank das gleiche Datenmodell verwendet.</span><span class="sxs-lookup"><span data-stu-id="30e0d-105">In traditional architectures, the same data model is used to query and update a database.</span></span> <span data-ttu-id="30e0d-106">Dies ist eine einfache Vorgehensweise, die für grundlegende CRUD-Vorgänge gut geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="30e0d-106">That's simple and works well for basic CRUD operations.</span></span> <span data-ttu-id="30e0d-107">Bei komplexeren Anwendungen kann dieser Ansatz aber zu Problemen führen.</span><span class="sxs-lookup"><span data-stu-id="30e0d-107">In more complex applications, however, this approach can become unwieldy.</span></span> <span data-ttu-id="30e0d-108">Beispielsweise werden von der Anwendung auf Leseseite unter Umständen unterschiedliche Abfragen durchgeführt und Datenübertragungsobjekte (Data Transfer Objects, DTOs) mit uneinheitlichen Formen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="30e0d-108">For example, on the read side, the application may perform many different queries, returning data transfer objects (DTOs) with different shapes.</span></span> <span data-ttu-id="30e0d-109">Die Objektzuordnung kann kompliziert werden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-109">Object mapping can become complicated.</span></span> <span data-ttu-id="30e0d-110">Auf der Schreibseite werden für das Modell ggf. eine komplexe Überprüfung und Geschäftslogik implementiert.</span><span class="sxs-lookup"><span data-stu-id="30e0d-110">On the write side, the model may implement complex validation and business logic.</span></span> <span data-ttu-id="30e0d-111">Hieraus kann sich ein Modell mit zu hoher Komplexität ergeben, das überdimensioniert ist.</span><span class="sxs-lookup"><span data-stu-id="30e0d-111">As a result, you can end up with an overly complex model that does too much.</span></span>

<span data-ttu-id="30e0d-112">Ein anderes potenzielles Problem ist, dass Lese- und Schreibworkloads häufig asymmetrisch sind und über sehr unterschiedliche Leistungs- und Skalierungsanforderungen verfügen.</span><span class="sxs-lookup"><span data-stu-id="30e0d-112">Another potential problem is that read and write workloads are often asymmetrical, with very different performance and scale requirements.</span></span> 

<span data-ttu-id="30e0d-113">CQRS löst diese Probleme, indem Lese- und Schreibvorgänge in separate Modelle unterteilt werden. Hierfür werden **Befehle** zum Aktualisieren von Daten und **Abfragen** zum Lesen von Daten verwendet.</span><span class="sxs-lookup"><span data-stu-id="30e0d-113">CQRS addresses these problems by separating reads and writes into separate models, using **commands** to update data, and **queries** to read data.</span></span>

- <span data-ttu-id="30e0d-114">Die Befehle sollten nicht datenzentriert, sondern aufgabenbasiert sein.</span><span class="sxs-lookup"><span data-stu-id="30e0d-114">Commands should be task based, rather than data centric.</span></span> <span data-ttu-id="30e0d-115">(Beispiel: „Hotelzimmer buchen“, nicht „Reservierungsstatus auf ‚Reserviert‘ festlegen“.) Befehle können in eine Warteschlange für die asynchrone Verarbeitung eingereiht werden, anstatt synchron verarbeitet zu werden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-115">("Book hotel room," not "set ReservationStatus to Reserved.") Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously.</span></span>

- <span data-ttu-id="30e0d-116">Mit Abfragen wird die Datenbank niemals geändert.</span><span class="sxs-lookup"><span data-stu-id="30e0d-116">Queries never modify the database.</span></span> <span data-ttu-id="30e0d-117">Eine Abfrage gibt ein DTO zurück, in dem kein Domänenwissen gekapselt ist.</span><span class="sxs-lookup"><span data-stu-id="30e0d-117">A query returns a DTO that does not encapsulate any domain knowledge.</span></span>

<span data-ttu-id="30e0d-118">Eine stärkere Isolation erzielen Sie, indem Sie die Lesedaten physisch von den Schreibdaten trennen.</span><span class="sxs-lookup"><span data-stu-id="30e0d-118">For greater isolation, you can physically separate the read data from the write data.</span></span> <span data-ttu-id="30e0d-119">In diesem Fall kann die Lesedatenbank ihr eigenes Datenschema verwenden, das für Abfragen optimiert ist.</span><span class="sxs-lookup"><span data-stu-id="30e0d-119">In that case, the read database can use its own data schema that is optimized for queries.</span></span> <span data-ttu-id="30e0d-120">Beispielsweise kann eine [materialisierte Sicht][materialized-view] der Daten gespeichert werden, um komplexe Verknüpfungen oder O/RM-Zuordnungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-120">For example, it can store a [materialized view][materialized-view] of the data, in order to avoid complex joins or complex O/RM mappings.</span></span> <span data-ttu-id="30e0d-121">Es kann sogar ein anderer Typ von Datenspeicher verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-121">It might even use a different type of data store.</span></span> <span data-ttu-id="30e0d-122">Die Schreibdatenbank kann beispielsweise relational sein, während es sich bei der Lesedatenbank um eine Dokumentdatenbank handelt.</span><span class="sxs-lookup"><span data-stu-id="30e0d-122">For example, the write database might be relational, while the read database is a document database.</span></span>

<span data-ttu-id="30e0d-123">Wenn separate Lese- und Schreibdatenbanken verwendet werden, müssen sie synchron gehalten werden. Dies wird normalerweise erreicht, indem das Schreibmodell jeweils ein Ereignis veröffentlicht, wenn es die Datenbank aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="30e0d-123">If separate read and write databases are used, they must be kept in sync. Typically this is accomplished by  having the write model publish an event whenever it updates the database.</span></span> <span data-ttu-id="30e0d-124">Die Aktualisierung der Datenbank und die Veröffentlichung des Ereignisses müssen in einer einzelnen Transaktion durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-124">Updating the database and publishing the event must occur in a single transaction.</span></span> 

<span data-ttu-id="30e0d-125">Für einige Implementierungen von CQRS wird das [Muster für die Ereignisherkunftsermittlung][event-sourcing] verwendet.</span><span class="sxs-lookup"><span data-stu-id="30e0d-125">Some implementations of CQRS use the [Event Sourcing pattern][event-sourcing].</span></span> <span data-ttu-id="30e0d-126">Bei diesem Muster wird der Anwendungsstatus als Ereignissequenz gespeichert.</span><span class="sxs-lookup"><span data-stu-id="30e0d-126">With this pattern, application state is stored as a sequence of events.</span></span> <span data-ttu-id="30e0d-127">Jedes Ereignis umfasst eine Reihe von Änderungen der Daten.</span><span class="sxs-lookup"><span data-stu-id="30e0d-127">Each event represents a set of changes to the data.</span></span> <span data-ttu-id="30e0d-128">Der aktuelle Zustand wird hergestellt, indem die Ereignisse erneut durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-128">The current state is constructed by replaying the events.</span></span> <span data-ttu-id="30e0d-129">In einem CQRS-Kontext besteht ein Vorteil der Ereignisherkunftsermittlung darin, dass dieselben Ereignisse verwendet werden können, um andere Komponenten zu benachrichtigen, z.B. vor allem das Lesemodell.</span><span class="sxs-lookup"><span data-stu-id="30e0d-129">In a CQRS context, one benefit of Event Sourcing is that the same events can be used to notify other components &mdash; in particular, to notify the read model.</span></span> <span data-ttu-id="30e0d-130">Im Lesemodell werden die Ereignisse genutzt, um eine Momentaufnahme des aktuellen Zustands zu erstellen, da dies für Abfragen effizienter ist.</span><span class="sxs-lookup"><span data-stu-id="30e0d-130">The read model uses the events to create a snapshot of the current state, which is more efficient for queries.</span></span> <span data-ttu-id="30e0d-131">Mit der Ereignisherkunftsermittlung erhöht sich aber auch die Komplexität des Designs.</span><span class="sxs-lookup"><span data-stu-id="30e0d-131">However, Event Sourcing adds complexity to the design.</span></span>

![](./images/cqrs-events.svg)

## <a name="when-to-use-this-architecture"></a><span data-ttu-id="30e0d-132">Einsatzmöglichkeiten für diese Architektur</span><span class="sxs-lookup"><span data-stu-id="30e0d-132">When to use this architecture</span></span>

<span data-ttu-id="30e0d-133">Erwägen Sie den Einsatz von CQRS für Kollaborationsdomänen, in denen viele Benutzer auf die gleichen Daten zugreifen – vor allem, wenn die Lese- und Schreibworkloads asymmetrisch sind.</span><span class="sxs-lookup"><span data-stu-id="30e0d-133">Consider CQRS for collaborative domains where many users access the same data, especially when the read and write workloads are asymmetrical.</span></span>

<span data-ttu-id="30e0d-134">CQRS ist keine Architektur der obersten Ebene, die für ein gesamtes System gilt.</span><span class="sxs-lookup"><span data-stu-id="30e0d-134">CQRS is not a top-level architecture that applies to an entire system.</span></span> <span data-ttu-id="30e0d-135">Wenden Sie CQRS nur auf die Subsysteme an, wenn das Trennen von Lese- und Schreibvorgängen einen eindeutigen Nutzen hat.</span><span class="sxs-lookup"><span data-stu-id="30e0d-135">Apply CQRS only to those subsystems where there is clear value in separating reads and writes.</span></span> <span data-ttu-id="30e0d-136">Andernfalls erhöhen Sie die Komplexität, ohne dass sich daraus ein Vorteil ergibt.</span><span class="sxs-lookup"><span data-stu-id="30e0d-136">Otherwise, you are creating additional complexity for no benefit.</span></span>

## <a name="benefits"></a><span data-ttu-id="30e0d-137">Vorteile</span><span class="sxs-lookup"><span data-stu-id="30e0d-137">Benefits</span></span>

- <span data-ttu-id="30e0d-138">**Unabhängige Skalierung**:</span><span class="sxs-lookup"><span data-stu-id="30e0d-138">**Independently scaling**.</span></span> <span data-ttu-id="30e0d-139">CQRS ermöglicht das unabhängige Skalieren der Lese- und Schreibworkloads und kann zu einer Verringerung von Sperrkonflikten führen.</span><span class="sxs-lookup"><span data-stu-id="30e0d-139">CQRS allows the read and write workloads to scale independently, and may result in fewer lock contentions.</span></span>
- <span data-ttu-id="30e0d-140">**Optimierte Datenschemas**:</span><span class="sxs-lookup"><span data-stu-id="30e0d-140">**Optimized data schemas.**</span></span>  <span data-ttu-id="30e0d-141">Auf der Leseseite kann ein Schema verwendet werden, das für Abfragen optimiert ist, während auf der Schreibseite ein Schema verwendet wird, das für Updates optimiert ist.</span><span class="sxs-lookup"><span data-stu-id="30e0d-141">The read side can use a schema that is optimized for queries, while the write side uses a schema that is optimized for updates.</span></span>  
- <span data-ttu-id="30e0d-142">**Sicherheit**.</span><span class="sxs-lookup"><span data-stu-id="30e0d-142">**Security**.</span></span> <span data-ttu-id="30e0d-143">Es ist einfacher sicherzustellen, dass nur die richtigen Domänenentitäten Schreibvorgänge für die Daten durchführen.</span><span class="sxs-lookup"><span data-stu-id="30e0d-143">It's easier to ensure that only the right domain entities are performing writes on the data.</span></span>
- <span data-ttu-id="30e0d-144">**Trennung von Zuständigkeiten**:</span><span class="sxs-lookup"><span data-stu-id="30e0d-144">**Separation of concerns**.</span></span> <span data-ttu-id="30e0d-145">Das Trennen der Lese- und Schreibseite kann zu Modellen führen, die besser gewartet werden können und flexibler sind.</span><span class="sxs-lookup"><span data-stu-id="30e0d-145">Segregating the read and write sides can result in models that are more maintainable and flexible.</span></span> <span data-ttu-id="30e0d-146">Der größte Teil der komplexen Geschäftslogik betrifft das Schreibmodell.</span><span class="sxs-lookup"><span data-stu-id="30e0d-146">Most of the complex business logic goes into the write model.</span></span> <span data-ttu-id="30e0d-147">Das Lesemodell kann relativ einfach gestaltet sein.</span><span class="sxs-lookup"><span data-stu-id="30e0d-147">The read model can be relatively simple.</span></span>
- <span data-ttu-id="30e0d-148">**Einfachere Abfragen**:</span><span class="sxs-lookup"><span data-stu-id="30e0d-148">**Simpler queries**.</span></span> <span data-ttu-id="30e0d-149">Indem eine materialisierte Sicht in der Lesedatenbank gespeichert wird, kann die Anwendung beim Durchführen von Abfragen komplexe Verknüpfungen vermeiden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-149">By storing a materialized view in the read database, the application can avoid complex joins when querying.</span></span>

## <a name="challenges"></a><span data-ttu-id="30e0d-150">Herausforderungen</span><span class="sxs-lookup"><span data-stu-id="30e0d-150">Challenges</span></span>

- <span data-ttu-id="30e0d-151">**Komplexität**:</span><span class="sxs-lookup"><span data-stu-id="30e0d-151">**Complexity**.</span></span> <span data-ttu-id="30e0d-152">Die Grundidee von CQRS ist einfach.</span><span class="sxs-lookup"><span data-stu-id="30e0d-152">The basic idea of CQRS is simple.</span></span> <span data-ttu-id="30e0d-153">Es kann sich aber auch ein komplexeres Anwendungsdesign ergeben, z.B. bei Verwendung des Musters für die Ereignisherkunftsermittlung.</span><span class="sxs-lookup"><span data-stu-id="30e0d-153">But it can lead to a more complex application design, especially if they include the Event Sourcing pattern.</span></span>

- <span data-ttu-id="30e0d-154">**Messaging**:</span><span class="sxs-lookup"><span data-stu-id="30e0d-154">**Messaging**.</span></span> <span data-ttu-id="30e0d-155">Für CQRS wird zwar kein Messaging benötigt, aber es wird trotzdem häufig genutzt, um Befehle zu verarbeiten und Aktualisierungsereignisse zu veröffentlichen.</span><span class="sxs-lookup"><span data-stu-id="30e0d-155">Although CQRS does not require messaging, it's common to use messaging to process commands and publish update events.</span></span> <span data-ttu-id="30e0d-156">In diesem Fall muss die Anwendung Nachrichtenfehler oder doppelte Nachrichten verarbeiten können.</span><span class="sxs-lookup"><span data-stu-id="30e0d-156">In that case, the application must handle message failures or duplicate messages.</span></span> 

- <span data-ttu-id="30e0d-157">**Letztliche Konsistenz**:</span><span class="sxs-lookup"><span data-stu-id="30e0d-157">**Eventual consistency**.</span></span> <span data-ttu-id="30e0d-158">Wenn Sie die Lese- und Schreibdatenbanken trennen, kann es sein, dass die Lesedaten veraltet sind.</span><span class="sxs-lookup"><span data-stu-id="30e0d-158">If you separate the read and write databases, the read data may be stale.</span></span> 

## <a name="best-practices"></a><span data-ttu-id="30e0d-159">Bewährte Methoden</span><span class="sxs-lookup"><span data-stu-id="30e0d-159">Best practices</span></span>

- <span data-ttu-id="30e0d-160">Weitere Informationen zur Implementierung von CQRS finden Sie unter [CQRS-Muster][cqrs-pattern].</span><span class="sxs-lookup"><span data-stu-id="30e0d-160">For more information about implementing CQRS, see [CQRS Pattern][cqrs-pattern].</span></span>

- <span data-ttu-id="30e0d-161">Erwägen Sie die Verwendung des Musters für die [Ereignisherkunftsermittlung][event-sourcing], um Aktualisierungskonflikte zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="30e0d-161">Consider using the [Event Sourcing][event-sourcing] pattern to avoid update conflicts.</span></span>

- <span data-ttu-id="30e0d-162">Erwägen Sie die Verwendung des [Musters für materialisierte Sichten][materialized-view] für das Lesemodell, um das Schema für Abfragen zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="30e0d-162">Consider using the [Materialized View pattern][materialized-view] for the read model, to optimize the schema for queries.</span></span>

## <a name="cqrs-in-microservices"></a><span data-ttu-id="30e0d-163">CQRS in Microservices</span><span class="sxs-lookup"><span data-stu-id="30e0d-163">CQRS in microservices</span></span>

<span data-ttu-id="30e0d-164">CQRS kann in einer [Microservices-Architektur][microservices] besonders nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="30e0d-164">CQRS can be especially useful in a [microservices architecture][microservices].</span></span> <span data-ttu-id="30e0d-165">Eines der Grundprinzipien von Microservices ist, dass ein Dienst nicht direkt auf den Datenspeicher eines anderen Diensts zugreifen kann.</span><span class="sxs-lookup"><span data-stu-id="30e0d-165">One of the principles of microservices is that a service cannot directly access another service's data store.</span></span>

![](./images/cqrs-microservices-wrong.png)

<span data-ttu-id="30e0d-166">Im folgenden Diagramm schreibt Dienst A in einen Datenspeicher, und Dienst B erstellt eine materialisierte Sicht der Daten.</span><span class="sxs-lookup"><span data-stu-id="30e0d-166">In the following diagram, Service A writes to a data store, and Service B keeps a materialized view of the data.</span></span> <span data-ttu-id="30e0d-167">Dienst A veröffentlicht jeweils ein Ereignis, wenn ein Schreibvorgang in den Datenspeicher durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="30e0d-167">Service A publishes an event whenever it writes to the data store.</span></span> <span data-ttu-id="30e0d-168">Dienst B abonniert das Ereignis.</span><span class="sxs-lookup"><span data-stu-id="30e0d-168">Service B subscribes to the event.</span></span>

![](./images/cqrs-microservices-right.png)


<!-- links -->

[cqrs-pattern]: ../../patterns/cqrs.md
[event-sourcing]: ../../patterns/event-sourcing.md
[materialized-view]: ../../patterns/materialized-view.md
[microservices]: ./microservices.md
